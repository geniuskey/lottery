<!--
@game-meta
{
  "id": "ladder-game",
  "title": "ì‚¬ë‹¤ë¦¬ ì¶”ì²¨",
  "emoji": "ğŸªœ",
  "category": "ì¶”ì²¨",
  "description": "ì‚¬ë‹¤ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ ìš´ëª…ì˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”! ê³µì •í•˜ê³  ì¬ë¯¸ìˆëŠ” ì‚¬ë‹¤ë¦¬ íƒ€ê¸° ê²Œì„",
  "features": ["ğŸ² ëœë¤ ì‚¬ë‹¤ë¦¬", "âœ¨ ì• ë‹ˆë©”ì´ì…˜"],
  "color": "blue",
  "badge": "NEW",
  "version": "1.1.0",
  "updated": "2025-12-20",
  "author": {
    "name": "Euiyun Edwin Kim",
    "email": "geniuskey@gmail.com",
    "github": "geniuskey"
  },
  "urls": {
    "service": "https://geniuskey.github.io/lottery/ladder/",
    "repository": "https://github.com/geniuskey/lottery"
  },
  "license": "MIT",
  "copyright": "Â© 2025 Euiyun Edwin Kim. Licensed under the MIT License."
}
@end-game-meta
-->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸªœ ì‚¬ë‹¤ë¦¬ ì¶”ì²¨ ê²Œì„</title>

    <!-- SEO ê¸°ë³¸ -->
    <meta name="description" content="ì‚¬ë‹¤ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ ìš´ëª…ì˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”! ê³µì •í•˜ê³  ì¬ë¯¸ìˆëŠ” ì‚¬ë‹¤ë¦¬ íƒ€ê¸° ê²Œì„">
    <meta name="author" content="Euiyun Edwin Kim">
    <meta name="keywords" content="ì‚¬ë‹¤ë¦¬ íƒ€ê¸°, ì‚¬ë‹¤ë¦¬ ê²Œì„, ì¶”ì²¨, ê²Œì„, lottery, ëœë¤ ì¶”ì²¨">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="ì¶”ì²¨ ê²Œì„ í¬íƒˆ">
    <meta property="og:title" content="ğŸªœ ì‚¬ë‹¤ë¦¬ ì¶”ì²¨ ê²Œì„">
    <meta property="og:description" content="ì‚¬ë‹¤ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ ìš´ëª…ì˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”! ê³µì •í•˜ê³  ì¬ë¯¸ìˆëŠ” ì‚¬ë‹¤ë¦¬ íƒ€ê¸° ê²Œì„">
    <meta property="og:url" content="https://geniuskey.github.io/lottery/ladder/">
    <meta property="og:locale" content="ko_KR">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="ğŸªœ ì‚¬ë‹¤ë¦¬ ì¶”ì²¨ ê²Œì„">
    <meta name="twitter:description" content="ì‚¬ë‹¤ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ ìš´ëª…ì˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”! ê³µì •í•˜ê³  ì¬ë¯¸ìˆëŠ” ì‚¬ë‹¤ë¦¬ íƒ€ê¸° ê²Œì„">

    <!-- ì¶”ê°€ SEO -->
    <link rel="canonical" href="https://geniuskey.github.io/lottery/ladder/">
    <meta name="robots" content="index, follow">

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .sidebar-header h1 {
            font-size: 1.5rem;
            font-weight: 900;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .sidebar-header h1 .emoji {
            /* ì´ëª¨ì§€ëŠ” ê¸°ë³¸ ìƒ‰ìƒ ìœ ì§€ */
        }

        .sidebar-header h1 .title-text {
            background: linear-gradient(135deg, #3b82f6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .help-btn {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #3b82f6;
            width: 24px;
            height: 24px;
            min-width: 24px;
            min-height: 24px;
            max-width: 24px;
            max-height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 700;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            padding: 0 !important;
            margin: 0;
            line-height: 1;
            flex-shrink: 0;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            box-sizing: border-box;
        }

        .help-btn:hover {
            background: rgba(59, 130, 246, 0.3);
            transform: scale(1.1);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 700;
        }

        textarea, input, select {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: #fff;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            transition: all 0.3s;
        }

        textarea:focus, input:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        textarea {
            min-height: 80px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .start-btn {
            background: linear-gradient(135deg, #3b82f6, #06b6d4);
            color: white;
        }

        .start-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(59, 130, 246, 0.4);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            flex: 0.3;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .result-board {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .result-board h3 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: #3b82f6;
            flex-shrink: 0;
        }

        .result-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            flex: 1;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .result-item.highlight {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(6, 182, 212, 0.3));
            border: 1px solid rgba(59, 130, 246, 0.5);
        }

        .sidebar-footer {
            display: flex;
            gap: 8px;
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .icon-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .icon-btn:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 0.75rem;
            white-space: nowrap;
            border-radius: 4px;
            pointer-events: none;
        }

        /* Game Area */
        .game-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 20px;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            max-height: 100%;
            background: rgba(255, 255, 255, 0.02);
        }

        .copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.25);
            pointer-events: none;
            user-select: none;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #3b82f6;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .modal-content p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.8);
        }

        .modal-close {
            margin-top: 20px;
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #3b82f6, #06b6d4);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .game-area {
                flex: 1;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1><span class="emoji">ğŸªœ</span> <span class="title-text">ì‚¬ë‹¤ë¦¬ ì¶”ì²¨</span></h1>
                <button class="help-btn" id="helpBtn">?</button>
            </div>

            <div class="input-group">
                <label>ì°¸ì—¬ì (ì½¤ë§ˆë¡œ êµ¬ë¶„)</label>
                <textarea id="participantsInput" placeholder="ì˜ìˆ˜, ì˜í˜¸, ì˜ì‹, ì˜ì² ">ì˜ìˆ˜, ì˜í˜¸, ì˜ì‹, ì˜ì² </textarea>
            </div>

            <div class="input-group">
                <label>ë‹¹ì²¨ ê²°ê³¼ (ì½¤ë§ˆë¡œ êµ¬ë¶„, ë‚˜ë¨¸ì§€ëŠ” ê½)</label>
                <textarea id="resultsInput" placeholder="ë‹¹ì²¨, ì»¤í”¼">ë‹¹ì²¨</textarea>
            </div>

            <div class="input-group">
                <label>ê°€ë¡œì„  ê°œìˆ˜</label>
                <input type="number" id="bridgesInput" min="5" max="30" value="15">
            </div>

            <div class="button-group">
                <button class="start-btn" id="revealAllBtn" disabled>ğŸ‘ï¸ ì „ì²´ ê²°ê³¼</button>
                <button class="reset-btn" id="resetBtn">â†º</button>
            </div>

            <div class="result-board">
                <h3>ğŸ¯ ì¶”ì²¨ ê²°ê³¼</h3>
                <div class="result-list" id="resultList">
                    <div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">
                        ì‚¬ë‹¤ë¦¬ë¥¼ ê·¸ë ¤ì£¼ì„¸ìš”!
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <a href="https://geniuskey.github.io/lottery/" class="icon-btn" data-tooltip="ì¶”ì²¨ í¬íƒˆ í™ˆ">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
                </a>
                <button class="icon-btn" id="copyResultBtn" data-tooltip="ê²°ê³¼ ë³µì‚¬">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                </button>
                <a href="https://github.com/geniuskey/lottery" target="_blank" class="icon-btn" data-tooltip="GitHub ì €ì¥ì†Œ">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>
                </a>
                <a href="https://buymeacoffee.com/euiyun" target="_blank" class="icon-btn" data-tooltip="ì»¤í”¼ ì‚¬ì£¼ê¸° â˜•">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.233-2.416.359-4.866.54-7.308.46-1.748-.06-3.477-.254-5.207-.498-.17-.024-.353-.055-.47-.18-.22-.236-.111-.71-.054-.995.052-.26.152-.609.463-.646.484-.057 1.046.148 1.526.22.577.088 1.156.159 1.737.212 2.48.226 5.002.19 7.472-.14.45-.06.899-.13 1.345-.21.399-.072.84-.206 1.08.206.166.281.188.657.162.974a.544.544 0 01-.169.364z"></path></svg>
                </a>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="copyright">Â© 2025 Euiyun Edwin Kim.</div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content">
            <h2>ğŸªœ ê²Œì„ ë°©ë²•</h2>
            <p><strong>ğŸ¯ ê²Œì„ ëª©í‘œ</strong><br>
            ì‚¬ë‹¤ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ ê° ì°¸ì—¬ìì˜ ìš´ëª…ì„ ê²°ì •í•˜ì„¸ìš”!</p>

            <p><strong>ğŸ“– ê²Œì„ ê·œì¹™</strong><br>
            1. ì°¸ì—¬ì ì´ë¦„ì„ ì…ë ¥í•©ë‹ˆë‹¤ (ì½¤ë§ˆë¡œ êµ¬ë¶„)<br>
            2. ë‹¹ì²¨ ê²°ê³¼ë§Œ ì…ë ¥í•©ë‹ˆë‹¤ (ë‚˜ë¨¸ì§€ëŠ” ìë™ìœ¼ë¡œ ê½ ì²˜ë¦¬)<br>
            3. ê°€ë¡œì„  ê°œìˆ˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (5~30ê°œ)<br>
            4. â†º ë²„íŠ¼ìœ¼ë¡œ ì‚¬ë‹¤ë¦¬ì™€ ì°¸ì—¬ì ìœ„ì¹˜ë¥¼ ì„ê¸°<br>
            5. ì‚¬ë‹¤ë¦¬ ì¤‘ì•™ì˜ "ğŸ® ì‹œì‘" ì˜ì—­ì„ í´ë¦­í•˜ë©´ ê°€ë ¤ì§„ ë¶€ë¶„ì´ ê³µê°œë©ë‹ˆë‹¤<br>
            6. ìƒë‹¨ ì°¸ì—¬ì ì´ë¦„ì„ í´ë¦­í•˜ë©´ ê°œë³„ ê²°ê³¼ í™•ì¸<br>
            7. "ğŸ‘ï¸ ì „ì²´ ê²°ê³¼" ë²„íŠ¼ìœ¼ë¡œ ë‚¨ì€ ëª¨ë“  ê²°ê³¼ë¥¼ í•œë²ˆì— í™•ì¸</p>

            <p><strong>âš™ï¸ ì„¤ì •</strong><br>
            â€¢ ì°¸ì—¬ì: ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥ (ì˜ˆ: ì˜ìˆ˜, ì˜í˜¸, ì˜ì‹)<br>
            â€¢ ë‹¹ì²¨ ê²°ê³¼: ì˜ë¯¸ìˆëŠ” ê²°ê³¼ë§Œ ì…ë ¥ (ì˜ˆ: ë‹¹ì²¨, ì»¤í”¼)<br>
            â€¢ ê°€ë¡œì„ : 5~30ê°œ ì‚¬ì´ë¡œ ì„¤ì • (ë§ì„ìˆ˜ë¡ ë³µì¡í•´ì§)<br>
            â€¢ 10ëª… ì°¸ì—¬í•´ë„ 1-2ê°œë§Œ ë‹¹ì²¨ ê²°ê³¼ ì„¤ì • ê°€ëŠ¥</p>

            <p><strong>ğŸ’¡ ê²Œì„ íŠ¹ì§•</strong><br>
            â€¢ ëœë¤ ì‚¬ë‹¤ë¦¬: ë§¤ë²ˆ ë‹¤ë¥¸ íŒ¨í„´ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤<br>
            â€¢ ì• ë‹ˆë©”ì´ì…˜: ì°¸ì—¬ìë¥¼ í´ë¦­í•˜ë©´ ê²½ë¡œê°€ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤<br>
            â€¢ ê³µì •ì„±: ì™„ì „í•œ ë¬´ì‘ìœ„ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©<br>
            â€¢ ê²°ê³¼ ë³µì‚¬: ê²°ê³¼ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>

            <button class="modal-close" id="closeModalBtn">í™•ì¸</button>
        </div>
    </div>

    <script>
        // Canvas ì„¤ì •
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ì°¸ì—¬ìë³„ ìƒ‰ìƒ ë°°ì—´
        const pathColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
            '#F8B500', '#00CED1', '#FF69B4', '#32CD32', '#FF4500'
        ];

        // ê²Œì„ ìƒíƒœ
        let ladder = null;
        let participants = [];
        let results = [];
        let numBridges = 15;
        let matchingResults = {};
        let revealedParticipants = []; // ê²°ê³¼ê°€ ê³µê°œëœ ì°¸ì—¬ì ì¸ë±ìŠ¤
        let drawnPaths = []; // ê·¸ë ¤ì§„ ê²½ë¡œë“¤
        let gameState = 'setup'; // 'setup' (ë§ˆìŠ¤í¬ë¨), 'revealed' (ê³µê°œë¨), 'running' (ì• ë‹ˆë©”ì´ì…˜ ì¤‘), 'finished' (ì™„ë£Œ)
        let isAnimating = false;

        // ë°˜ì‘í˜• ìº”ë²„ìŠ¤ í¬ê¸°
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(container.clientWidth - 40, 1000);
            const maxHeight = Math.min(container.clientHeight - 40, 800);
            canvas.width = maxWidth;
            canvas.height = maxHeight;

            if (ladder) {
                drawLadder();
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI ìš”ì†Œ
        const participantsInput = document.getElementById('participantsInput');
        const resultsInput = document.getElementById('resultsInput');
        const bridgesInput = document.getElementById('bridgesInput');
        const revealAllBtn = document.getElementById('revealAllBtn');
        const resetBtn = document.getElementById('resetBtn');
        const resultList = document.getElementById('resultList');
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const copyResultBtn = document.getElementById('copyResultBtn');

        // LocalStorage
        function saveSettings() {
            localStorage.setItem('ladderGame_participants', participantsInput.value);
            localStorage.setItem('ladderGame_results', resultsInput.value);
            localStorage.setItem('ladderGame_bridges', bridgesInput.value);
        }

        function loadSettings() {
            const savedParticipants = localStorage.getItem('ladderGame_participants');
            const savedResults = localStorage.getItem('ladderGame_results');
            const savedBridges = localStorage.getItem('ladderGame_bridges');
            if (savedParticipants) participantsInput.value = savedParticipants;
            if (savedResults) resultsInput.value = savedResults;
            if (savedBridges) bridgesInput.value = savedBridges;
        }

        loadSettings();
        participantsInput.addEventListener('input', saveSettings);
        resultsInput.addEventListener('input', saveSettings);
        bridgesInput.addEventListener('input', () => {
            saveSettings();
            // ê²Œì„ ì‹œì‘ í›„ ê°€ë¡œì„  ê°œìˆ˜ ë³€ê²½ ì‹œ ì´ˆê¸°í™”
            if (gameState !== 'setup') {
                generateLadder();
            }
        });

        // ë„ì›€ë§ ëª¨ë‹¬
        helpBtn.addEventListener('click', () => {
            helpModal.classList.add('active');
        });

        closeModalBtn.addEventListener('click', () => {
            helpModal.classList.remove('active');
        });

        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.remove('active');
            }
        });

        // ê²°ê³¼ ë°°ì—´ ìƒì„± (ë‹¹ì²¨ ê²°ê³¼ + ë‚˜ë¨¸ì§€ ê½)
        function generateResults(winningResults, count) {
            const allResults = [...winningResults];
            while (allResults.length < count) {
                allResults.push('ê½');
            }
            // ê²°ê³¼ ì„ê¸°
            for (let i = allResults.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allResults[i], allResults[j]] = [allResults[j], allResults[i]];
            }
            return allResults;
        }

        // Ladder í´ë˜ìŠ¤
        class Ladder {
            constructor(participants, results, numBridges) {
                this.participants = participants;
                this.results = results;
                this.numBridges = numBridges;
                this.numLines = participants.length;

                // ë ˆì´ì•„ì›ƒ ê³„ì‚°
                this.padding = 60;
                this.topPadding = 80;
                this.bottomPadding = 80;
                this.lineSpacing = (canvas.width - this.padding * 2) / (this.numLines - 1);
                this.height = canvas.height - this.topPadding - this.bottomPadding;
                this.segmentHeight = this.height / (this.numBridges + 1);

                // ê°€ë¡œì„  ìƒì„±
                this.bridges = this.generateBridges();

                // ê²½ë¡œ ê³„ì‚°
                this.paths = this.calculatePaths();

                // ê° ì°¸ì—¬ìë³„ ìƒ‰ìƒ
                this.colors = participants.map((_, i) => pathColors[i % pathColors.length]);
            }

            generateBridges() {
                const bridges = [];

                for (let row = 1; row <= this.numBridges; row++) {
                    const y = this.topPadding + row * this.segmentHeight;

                    // ê° í–‰ì—ì„œ ëœë¤í•˜ê²Œ ê°€ë¡œì„  ìƒì„±
                    const possiblePositions = [];
                    for (let i = 0; i < this.numLines - 1; i++) {
                        possiblePositions.push(i);
                    }

                    // ëœë¤í•˜ê²Œ ì„ê¸°
                    for (let i = possiblePositions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [possiblePositions[i], possiblePositions[j]] = [possiblePositions[j], possiblePositions[i]];
                    }

                    // ì´ í–‰ì—ì„œ ì‚¬ìš©ëœ ë¼ì¸ ì¸ë±ìŠ¤ ì¶”ì 
                    const usedLines = new Set();

                    // 30-70% ì •ë„ì˜ ê°€ë¡œì„  ìƒì„±
                    const numBridgesInRow = Math.floor(Math.random() * (this.numLines / 2)) + 1;
                    let addedCount = 0;

                    for (let i = 0; i < possiblePositions.length && addedCount < numBridgesInRow; i++) {
                        const lineIndex = possiblePositions[i];

                        // ì´ ê°€ë¡œì„ ì´ ì‚¬ìš©í•  ë‘ ë¼ì¸ (lineIndex, lineIndex + 1)
                        // ì¸ì ‘í•œ ê°€ë¡œì„ ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì²´í¬
                        // lineIndex-1, lineIndex, lineIndex+1, lineIndex+2 ì¤‘ í•˜ë‚˜ë¼ë„ ì‚¬ìš©ë˜ì—ˆìœ¼ë©´ ìŠ¤í‚µ
                        if (usedLines.has(lineIndex - 1) ||
                            usedLines.has(lineIndex) ||
                            usedLines.has(lineIndex + 1) ||
                            usedLines.has(lineIndex + 2)) {
                            continue;
                        }

                        bridges.push({
                            y: y,
                            fromLine: lineIndex,
                            toLine: lineIndex + 1
                        });

                        // ì‚¬ìš©ëœ ë¼ì¸ ê¸°ë¡
                        usedLines.add(lineIndex);
                        usedLines.add(lineIndex + 1);
                        addedCount++;
                    }
                }

                return bridges;
            }

            calculatePaths() {
                const paths = [];

                // ê°€ë¡œì„ ì„ y ì¢Œí‘œ ìˆœìœ¼ë¡œ ì •ë ¬
                const sortedBridges = [...this.bridges].sort((a, b) => a.y - b.y);

                for (let startLine = 0; startLine < this.numLines; startLine++) {
                    const path = [];
                    let currentLine = startLine;
                    let currentY = this.topPadding;

                    // ì‹œì‘ì 
                    path.push({
                        x: this.padding + currentLine * this.lineSpacing,
                        y: currentY
                    });

                    // ê° ê°€ë¡œì„ ì„ ìˆœì„œëŒ€ë¡œ ì²´í¬
                    for (const bridge of sortedBridges) {
                        // í˜„ì¬ ë¼ì¸ì´ ì´ ê°€ë¡œì„ ì— ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
                        if (bridge.fromLine === currentLine || bridge.toLine === currentLine) {
                            // ê°€ë¡œì„  ë§Œë‚˜ê¸° ì „ê¹Œì§€ ì§ì§„
                            path.push({
                                x: this.padding + currentLine * this.lineSpacing,
                                y: bridge.y
                            });

                            // ê°€ë¡œì„  íƒ€ê³  ì´ë™
                            currentLine = bridge.fromLine === currentLine ? bridge.toLine : bridge.fromLine;
                            path.push({
                                x: this.padding + currentLine * this.lineSpacing,
                                y: bridge.y
                            });

                            currentY = bridge.y;
                        }
                    }

                    // ë§ˆì§€ë§‰ê¹Œì§€ ì§ì§„
                    const endY = canvas.height - this.bottomPadding;
                    path.push({
                        x: this.padding + currentLine * this.lineSpacing,
                        y: endY
                    });

                    paths.push({
                        path: path,
                        endLine: currentLine
                    });
                }

                return paths;
            }

            draw(masked = false) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#0f0f1e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ë§ˆìŠ¤í¬ ì˜ì—­ ê³„ì‚° (ê²Œì„ ì˜ì—­ì˜ ì¤‘ì•™ 80% ê°€ë¦¼)
                const ladderTop = this.topPadding;
                const ladderBottom = canvas.height - this.bottomPadding;
                const ladderHeight = ladderBottom - ladderTop;
                const visibleTopY = ladderTop + ladderHeight * 0.1;  // ìƒë‹¨ 10% ë³´ì„
                const visibleBottomY = ladderBottom - ladderHeight * 0.1;  // í•˜ë‹¨ 10% ë³´ì„
                const maskTop = visibleTopY;
                const maskBottom = visibleBottomY;

                // ì„¸ë¡œì„  ê·¸ë¦¬ê¸°
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                ctx.lineWidth = 3;

                for (let i = 0; i < this.numLines; i++) {
                    const x = this.padding + i * this.lineSpacing;

                    if (masked) {
                        // ìƒë‹¨ 10% ë³´ì´ëŠ” ë¶€ë¶„
                        ctx.beginPath();
                        ctx.moveTo(x, ladderTop);
                        ctx.lineTo(x, visibleTopY);
                        ctx.stroke();

                        // í•˜ë‹¨ 10% ë³´ì´ëŠ” ë¶€ë¶„
                        ctx.beginPath();
                        ctx.moveTo(x, visibleBottomY);
                        ctx.lineTo(x, ladderBottom);
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(x, this.topPadding);
                        ctx.lineTo(x, canvas.height - this.bottomPadding);
                        ctx.stroke();
                    }
                }

                // ê°€ë¡œì„  ê·¸ë¦¬ê¸°
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgba(6, 182, 212, 0.6)';

                this.bridges.forEach(bridge => {
                    const x1 = this.padding + bridge.fromLine * this.lineSpacing;
                    const x2 = this.padding + bridge.toLine * this.lineSpacing;

                    if (masked) {
                        // ë§ˆìŠ¤í¬ ëª¨ë“œ: ë§ˆìŠ¤í¬ ì˜ì—­ ë°–ì˜ ê°€ë¡œì„ ë§Œ í‘œì‹œ
                        if (bridge.y < maskTop || bridge.y > maskBottom) {
                            ctx.beginPath();
                            ctx.moveTo(x1, bridge.y);
                            ctx.lineTo(x2, bridge.y);
                            ctx.stroke();
                        }
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: ì „ì²´ ê°€ë¡œì„  í‘œì‹œ
                        ctx.beginPath();
                        ctx.moveTo(x1, bridge.y);
                        ctx.lineTo(x2, bridge.y);
                        ctx.stroke();
                    }
                });

                // ë§ˆìŠ¤í¬ ì˜ì—­ ê·¸ë¦¬ê¸° (ì¤‘ì•™ 80%) - í´ë¦­ ê°€ëŠ¥í•œ ì‹œì‘ ë²„íŠ¼
                if (masked) {
                    // ë§ˆìŠ¤í¬ ì˜ì—­ ì €ì¥ (í´ë¦­ìš©)
                    this.maskArea = {
                        x: 10,
                        y: maskTop,
                        width: canvas.width - 20,
                        height: maskBottom - maskTop
                    };

                    // ë°˜íˆ¬ëª… ë§ˆìŠ¤í¬ ë°°ê²½
                    ctx.fillStyle = 'rgba(20, 20, 35, 0.95)';
                    ctx.fillRect(0, maskTop, canvas.width, maskBottom - maskTop);

                    // ë²„íŠ¼ ìŠ¤íƒ€ì¼ í…Œë‘ë¦¬
                    const gradient = ctx.createLinearGradient(0, maskTop, 0, maskBottom);
                    gradient.addColorStop(0, 'rgba(59, 130, 246, 0.6)');
                    gradient.addColorStop(1, 'rgba(6, 182, 212, 0.6)');
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(10, maskTop, canvas.width - 20, maskBottom - maskTop);

                    // ì‹œì‘ ë²„íŠ¼ í…ìŠ¤íŠ¸
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                    ctx.font = 'bold 48px "Noto Sans KR"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸ® ì‹œì‘', canvas.width / 2, (maskTop + maskBottom) / 2);

                    ctx.fillStyle = 'rgba(150, 150, 180, 0.6)';
                    ctx.font = 'bold 14px "Noto Sans KR"';
                    ctx.fillText('í´ë¦­í•˜ì—¬ ì‚¬ë‹¤ë¦¬ ê³µê°œ', canvas.width / 2, (maskTop + maskBottom) / 2 + 40);
                } else {
                    this.maskArea = null;
                }

                // ì°¸ì—¬ì ì´ë¦„ (ìœ„) - í´ë¦­ ê°€ëŠ¥í•˜ë„ë¡ ì €ì¥
                ctx.font = 'bold 16px "Noto Sans KR"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                this.participantBoxes = []; // í´ë¦­ ì˜ì—­ ì €ì¥

                this.participants.forEach((name, i) => {
                    const x = this.padding + i * this.lineSpacing;
                    const color = this.colors[i];
                    const textWidth = Math.max(ctx.measureText(name).width, 40);
                    const boxWidth = textWidth + 16;
                    const boxHeight = 30;
                    const boxX = x - boxWidth / 2;
                    const boxY = this.topPadding - 45;

                    // í´ë¦­ ì˜ì—­ ì €ì¥
                    this.participantBoxes.push({
                        x: boxX,
                        y: boxY,
                        width: boxWidth,
                        height: boxHeight,
                        index: i
                    });

                    // ë°°ê²½ - ì°¸ì—¬ìë³„ ìƒ‰ìƒ
                    ctx.fillStyle = this.hexToRgba(color, 0.3);
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

                    // í…Œë‘ë¦¬
                    ctx.strokeStyle = this.hexToRgba(color, 0.8);
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                    // í…ìŠ¤íŠ¸ (ì„¸ë¡œ ì¤‘ì•™)
                    ctx.fillStyle = '#fff';
                    ctx.fillText(name, x, boxY + boxHeight / 2);
                });

                // ê²°ê³¼ í•­ëª© (ì•„ë˜) - í…ìŠ¤íŠ¸ ì„¸ë¡œ ì¤‘ì•™ ì •ë ¬
                this.results.forEach((result, i) => {
                    const x = this.padding + i * this.lineSpacing;
                    const y = canvas.height - this.bottomPadding;
                    const isWin = result !== 'ê½';
                    const textWidth = Math.max(ctx.measureText(result).width, 40);
                    const boxWidth = textWidth + 16;
                    const boxHeight = 30;
                    const boxX = x - boxWidth / 2;
                    const boxY = y + 10;

                    // ë°°ê²½
                    ctx.fillStyle = isWin ? 'rgba(255, 215, 0, 0.3)' : 'rgba(100, 100, 100, 0.3)';
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

                    // í…Œë‘ë¦¬
                    ctx.strokeStyle = isWin ? 'rgba(255, 215, 0, 0.8)' : 'rgba(100, 100, 100, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                    // í…ìŠ¤íŠ¸ (ì„¸ë¡œ ì¤‘ì•™)
                    ctx.fillStyle = isWin ? '#FFD700' : 'rgba(255, 255, 255, 0.6)';
                    ctx.fillText(result, x, boxY + boxHeight / 2);
                });
            }

            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            async animatePath(startIndex, drawnPaths = []) {
                const pathData = this.paths[startIndex];
                const path = pathData.path;
                const color = this.colors[startIndex];

                // ì´ì „ì— ê·¸ë ¤ì§„ ê²½ë¡œë“¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                this.draw(false);
                for (const drawn of drawnPaths) {
                    this.drawCompletePath(drawn.pathIndex, drawn.color);
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // ì „ì²´ ê²½ë¡œì˜ ì„¸ê·¸ë¨¼íŠ¸ë“¤ì„ ì—°ì†ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                let fullPath = [];
                for (let i = 0; i < path.length; i++) {
                    fullPath.push(path[i]);
                }

                // ì´ ê±°ë¦¬ ê³„ì‚°
                let totalLength = 0;
                for (let i = 1; i < fullPath.length; i++) {
                    const dx = fullPath[i].x - fullPath[i-1].x;
                    const dy = fullPath[i].y - fullPath[i-1].y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                }

                // ì• ë‹ˆë©”ì´ì…˜ - ì—°ì† ì„ ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                const animationDuration = 960; // ms (20% ëŠë¦¬ê²Œ)
                const startTime = performance.now();

                await new Promise(resolve => {
                    const animate = (currentTime) => {
                        // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë‹¨ ì²´í¬
                        if (!isAnimating) {
                            resolve();
                            return;
                        }

                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / animationDuration, 1);
                        const targetLength = totalLength * progress;

                        // ì‚¬ë‹¤ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                        this.draw(false);

                        // ì´ì „ ê²½ë¡œë“¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                        for (const drawn of drawnPaths) {
                            this.drawCompletePath(drawn.pathIndex, drawn.color);
                        }

                        // í˜„ì¬ê¹Œì§€ì˜ ê²½ë¡œ ê·¸ë¦¬ê¸°
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(fullPath[0].x, fullPath[0].y);

                        let accumulatedLength = 0;
                        let lastX = fullPath[0].x;
                        let lastY = fullPath[0].y;

                        for (let i = 1; i < fullPath.length; i++) {
                            const dx = fullPath[i].x - fullPath[i-1].x;
                            const dy = fullPath[i].y - fullPath[i-1].y;
                            const segmentLength = Math.sqrt(dx * dx + dy * dy);

                            if (accumulatedLength + segmentLength <= targetLength) {
                                ctx.lineTo(fullPath[i].x, fullPath[i].y);
                                lastX = fullPath[i].x;
                                lastY = fullPath[i].y;
                                accumulatedLength += segmentLength;
                            } else {
                                const remainingLength = targetLength - accumulatedLength;
                                const t = remainingLength / segmentLength;
                                lastX = fullPath[i-1].x + dx * t;
                                lastY = fullPath[i-1].y + dy * t;
                                ctx.lineTo(lastX, lastY);
                                break;
                            }
                        }
                        ctx.stroke();

                        // í˜„ì¬ ìœ„ì¹˜ì— ì› ê·¸ë¦¬ê¸°
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(lastX, lastY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    requestAnimationFrame(animate);
                });

                // ìµœì¢… ê²°ê³¼ ê°•ì¡° (ê¸°ì¡´ ê²°ê³¼ ë°•ìŠ¤ì™€ ë™ì¼ ì‚¬ì´ì¦ˆë¡œ ë®ê¸°)
                const endLine = pathData.endLine;
                const resultX = this.padding + endLine * this.lineSpacing;
                const resultY = canvas.height - this.bottomPadding + 10;
                const resultText = this.results[endLine];

                ctx.font = 'bold 16px "Noto Sans KR"';
                const textWidth = Math.max(ctx.measureText(resultText).width, 40);
                const boxWidth = textWidth + 16;
                const boxHeight = 30;
                const boxX = resultX - boxWidth / 2;

                // ìƒ‰ìƒìœ¼ë¡œ ë®ê¸°
                ctx.fillStyle = this.hexToRgba(color, 0.5);
                ctx.fillRect(boxX, resultY, boxWidth, boxHeight);

                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(boxX, resultY, boxWidth, boxHeight);

                // ê²°ê³¼ í…ìŠ¤íŠ¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                const isWin = resultText !== 'ê½';
                ctx.fillStyle = isWin ? '#FFD700' : '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(resultText, resultX, resultY + boxHeight / 2);

                return endLine;
            }

            drawCompletePath(pathIndex, color) {
                const pathData = this.paths[pathIndex];
                const path = pathData.path;

                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);

                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();

                // ê²°ê³¼ ê°•ì¡° (ê¸°ì¡´ ê²°ê³¼ ë°•ìŠ¤ì™€ ë™ì¼ ì‚¬ì´ì¦ˆë¡œ ë®ê¸°)
                const endLine = pathData.endLine;
                const resultX = this.padding + endLine * this.lineSpacing;
                const resultY = canvas.height - this.bottomPadding + 10;
                const resultText = this.results[endLine];

                ctx.font = 'bold 16px "Noto Sans KR"';
                const textWidth = Math.max(ctx.measureText(resultText).width, 40);
                const boxWidth = textWidth + 16;
                const boxHeight = 30;
                const boxX = resultX - boxWidth / 2;

                // ìƒ‰ìƒìœ¼ë¡œ ë®ê¸°
                ctx.fillStyle = this.hexToRgba(color, 0.5);
                ctx.fillRect(boxX, resultY, boxWidth, boxHeight);

                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(boxX, resultY, boxWidth, boxHeight);

                // ê²°ê³¼ í…ìŠ¤íŠ¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                const isWin = resultText !== 'ê½';
                ctx.fillStyle = isWin ? '#FFD700' : '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(resultText, resultX, resultY + boxHeight / 2);
            }
        }

        // ì‚¬ë‹¤ë¦¬ ê·¸ë¦¬ê¸°
        function drawLadder() {
            if (ladder) {
                ladder.draw(gameState === 'setup');
            }
        }

        // ê²°ê³¼ ì—…ë°ì´íŠ¸
        function updateResults() {
            resultList.innerHTML = '';

            if (Object.keys(matchingResults).length === 0) {
                resultList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">ğŸ® ì‹œì‘ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”!</div>';
                return;
            }

            participants.forEach((name, i) => {
                if (matchingResults[name] !== undefined) {
                    const result = matchingResults[name];
                    const isWin = result !== 'ê½';
                    const item = document.createElement('div');
                    item.className = 'result-item' + (isWin ? ' highlight' : '');
                    item.innerHTML = `
                        <span style="color: ${ladder.colors[i]}">${name}</span>
                        <span style="color: ${isWin ? '#FFD700' : 'rgba(255,255,255,0.6)'}">â†’ ${result}</span>
                    `;
                    resultList.appendChild(item);
                }
            });
        }

        // ë°°ì—´ ì„ê¸° (Fisher-Yates)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // ì‚¬ë‹¤ë¦¬ ìƒì„± (ì´ˆê¸°í™”/ì„ê¸°)
        function generateLadder() {
            let rawParticipants = participantsInput.value.split(',').map(n => n.trim()).filter(n => n);
            const winningResults = resultsInput.value.split(',').map(n => n.trim()).filter(n => n);
            numBridges = parseInt(bridgesInput.value);

            if (rawParticipants.length < 2) {
                alert('ì°¸ì—¬ìê°€ ìµœì†Œ 2ëª… ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤!');
                return false;
            }

            if (numBridges < 5 || numBridges > 30) {
                alert('ê°€ë¡œì„  ê°œìˆ˜ëŠ” 5~30 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤!');
                return false;
            }

            // ì°¸ì—¬ì ìœ„ì¹˜ ëœë¤ ì„ê¸°
            participants = shuffleArray(rawParticipants);

            // ë‹¹ì²¨ ê²°ê³¼ + ë‚˜ë¨¸ì§€ ê½ìœ¼ë¡œ ì±„ìš°ê¸°
            results = generateResults(winningResults, participants.length);

            matchingResults = {};
            revealedParticipants = [];
            drawnPaths = [];
            ladder = new Ladder(participants, results, numBridges);
            gameState = 'setup';
            drawLadder();

            // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê²°ê³¼ ì—†ìœ¼ë¯€ë¡œ disabled)
            revealAllBtn.disabled = true;

            resultList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">ì‚¬ë‹¤ë¦¬ë¥¼ í´ë¦­í•˜ì—¬ ì‹œì‘!</div>';

            return true;
        }

        // ê²Œì„ ì‹œì‘ (ê°€ë¦¼ í•´ì œë§Œ)
        function startGame() {
            if (!ladder || gameState !== 'setup') return;

            gameState = 'revealed';

            // ê°€ë¦¼ í•´ì œí•˜ë©° ê·¸ë¦¬ê¸°
            ladder.draw(false);

            // ì „ì²´ ê²°ê³¼ ë²„íŠ¼ í™œì„±í™”
            revealAllBtn.disabled = false;

            resultList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">ì°¸ì—¬ìë¥¼ í´ë¦­í•˜ì„¸ìš”!</div>';
        }

        // ê°œë³„ ì°¸ì—¬ì ê²°ê³¼ ë³´ê¸°
        async function revealParticipant(index) {
            if (isAnimating || revealedParticipants.includes(index)) return;

            isAnimating = true;
            revealAllBtn.disabled = true;

            // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
            const resultIndex = await ladder.animatePath(index, drawnPaths);

            // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë‹¨ëœ ê²½ìš° (ì´ˆê¸°í™” ë²„íŠ¼ ëˆŒë¦¼)
            if (!isAnimating) return;

            matchingResults[participants[index]] = results[resultIndex];
            drawnPaths.push({ pathIndex: index, color: ladder.colors[index] });
            revealedParticipants.push(index);
            updateResults();

            isAnimating = false;

            // ëª¨ë“  ì°¸ì—¬ì ê³µê°œ ì™„ë£Œ ì‹œ
            if (revealedParticipants.length === participants.length) {
                gameState = 'finished';
                revealAllBtn.disabled = true;
            } else {
                // ì•„ì§ ê³µê°œ ì•ˆëœ ì°¸ì—¬ìê°€ ìˆìœ¼ë©´ ì „ì²´ ê²°ê³¼ ë²„íŠ¼ í™œì„±í™”
                revealAllBtn.disabled = false;
            }
        }

        // ì „ì²´ ê²°ê³¼ ë³´ê¸°
        async function revealAll() {
            if (isAnimating || gameState === 'setup') return;

            isAnimating = true;
            revealAllBtn.disabled = true;

            for (let i = 0; i < participants.length; i++) {
                // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë‹¨ëœ ê²½ìš° (ì´ˆê¸°í™” ë²„íŠ¼ ëˆŒë¦¼)
                if (!isAnimating) return;

                if (!revealedParticipants.includes(i)) {
                    const resultIndex = await ladder.animatePath(i, drawnPaths);

                    // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë‹¨ëœ ê²½ìš°
                    if (!isAnimating) return;

                    matchingResults[participants[i]] = results[resultIndex];
                    drawnPaths.push({ pathIndex: i, color: ladder.colors[i] });
                    revealedParticipants.push(i);
                    updateResults();

                    // ë‹¤ìŒ ì°¸ì—¬ì ì „ ì ì‹œ ëŒ€ê¸°
                    if (i < participants.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }
            }

            gameState = 'finished';
            isAnimating = false;
            revealAllBtn.disabled = true;
        }

        // ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ (ë§ˆìŠ¤í¬ í´ë¦­ ë˜ëŠ” ì°¸ì—¬ì í´ë¦­)
        canvas.addEventListener('click', (e) => {
            if (!ladder || isAnimating) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ë§ˆìŠ¤í¬ í´ë¦­ ì²´í¬ (ê²Œì„ ì‹œì‘)
            if (gameState === 'setup' && ladder.maskArea) {
                const mask = ladder.maskArea;
                if (x >= mask.x && x <= mask.x + mask.width &&
                    y >= mask.y && y <= mask.y + mask.height) {
                    startGame();
                    return;
                }
            }

            // ì°¸ì—¬ì ë°•ìŠ¤ í´ë¦­ ì²´í¬ (ê²Œì„ ì§„í–‰ ì¤‘)
            if (gameState === 'revealed' && ladder.participantBoxes) {
                for (const box of ladder.participantBoxes) {
                    if (x >= box.x && x <= box.x + box.width &&
                        y >= box.y && y <= box.y + box.height) {
                        revealParticipant(box.index);
                        break;
                    }
                }
            }
        });

        // ì»¤ì„œ ìŠ¤íƒ€ì¼ ë³€ê²½
        canvas.addEventListener('mousemove', (e) => {
            if (!ladder || isAnimating) {
                canvas.style.cursor = 'default';
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ë§ˆìŠ¤í¬ ìœ„ì— ìˆìœ¼ë©´ pointer
            if (gameState === 'setup' && ladder.maskArea) {
                const mask = ladder.maskArea;
                if (x >= mask.x && x <= mask.x + mask.width &&
                    y >= mask.y && y <= mask.y + mask.height) {
                    canvas.style.cursor = 'pointer';
                    return;
                }
            }

            // ì°¸ì—¬ì ìœ„ì— ìˆìœ¼ë©´ pointer
            let isOverParticipant = false;
            if (gameState === 'revealed' && ladder.participantBoxes) {
                for (const box of ladder.participantBoxes) {
                    if (x >= box.x && x <= box.x + box.width &&
                        y >= box.y && y <= box.y + box.height &&
                        !revealedParticipants.includes(box.index)) {
                        isOverParticipant = true;
                        break;
                    }
                }
            }

            canvas.style.cursor = isOverParticipant ? 'pointer' : 'default';
        });

        // ì „ì²´ ê²°ê³¼ ë³´ê¸° ë²„íŠ¼
        revealAllBtn.addEventListener('click', () => {
            if (gameState === 'revealed') {
                revealAll();
            }
        });

        // ì´ˆê¸°í™”/ì„ê¸° ë²„íŠ¼ (ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì—ë„ ë™ì‘)
        resetBtn.addEventListener('click', () => {
            isAnimating = false; // ì• ë‹ˆë©”ì´ì…˜ ê°•ì œ ì¤‘ë‹¨
            generateLadder();
        });

        // ê²°ê³¼ ë³µì‚¬
        copyResultBtn.addEventListener('click', () => {
            if (Object.keys(matchingResults).length === 0) {
                alert('ë¨¼ì € ê²Œì„ì„ ì§„í–‰í•´ì£¼ì„¸ìš”!');
                return;
            }

            let result = 'ğŸªœ ì‚¬ë‹¤ë¦¬ ì¶”ì²¨ ê²°ê³¼\n\n';

            participants.forEach((name, i) => {
                if (matchingResults[name] !== undefined) {
                    result += `${name} â†’ ${matchingResults[name]}\n`;
                }
            });

            navigator.clipboard.writeText(result).then(() => {
                const originalText = copyResultBtn.innerHTML;
                copyResultBtn.innerHTML = '<span style="color: #3b82f6;">âœ“</span>';
                setTimeout(() => {
                    copyResultBtn.innerHTML = originalText;
                }, 1000);
            });
        });

        // ì´ˆê¸° í™”ë©´ - ì‚¬ë‹¤ë¦¬ ìƒì„±
        generateLadder();
    </script>
</body>
</html>

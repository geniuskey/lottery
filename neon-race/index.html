<!--
@game-meta
{
  "id": "neon-race",
  "title": "ë„¤ì˜¨ ë ˆì´ìŠ¤",
  "emoji": "ğŸŒŒ",
  "category": "ë ˆì´ì‹±",
  "description": "ì‚¬ì´ë²„í‘í¬ ë„ì‹œë¥¼ ê°€ë¡œì§€ë¥´ëŠ” í™”ë ¤í•œ ë ˆì´ì‹±! ì•„ì´í…œì„ ì‚¬ìš©í•˜ì—¬ ì—­ì „ ìŠ¹ë¦¬ë¥¼ ë…¸ë¦¬ì„¸ìš”.",
  "features": ["ğŸ ì•„ì´í…œ ì‹œìŠ¤í…œ", "ğŸ§­ ì¸í„°ë™í‹°ë¸Œ ë¯¸ë‹ˆë§µ"],
  "color": "pink",
  "badge": "NEW",
  "version": "1.7.0",
  "updated": "2025-12-25",
  "author": {
    "name": "Euiyun Edwin Kim",
    "email": "geniuskey@gmail.com",
    "github": "geniuskey"
  },
  "urls": {
    "service": "https://geniuskey.github.io/lottery/neon-race/",
    "repository": "https://github.com/geniuskey/lottery"
  },
  "license": "MIT",
  "copyright": "Â© 2025 Euiyun Edwin Kim. Licensed under the MIT License."
}
@end-game-meta
-->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GFTNV73W8L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-GFTNV73W8L');
    </script>

    <title>ë„¤ì˜¨ ë ˆì´ìŠ¤ - ì¶”ì²¨ ê²Œì„ í¬í„¸</title>

    <!-- SEO ê¸°ë³¸ -->
    <meta name="description" content="ì‚¬ì´ë²„í‘í¬ ë„ì‹œë¥¼ ê°€ë¡œì§€ë¥´ëŠ” í™”ë ¤í•œ ë ˆì´ì‹±! ì•„ì´í…œì„ ì‚¬ìš©í•˜ì—¬ ì—­ì „ ìŠ¹ë¦¬ë¥¼ ë…¸ë¦¬ëŠ” ì˜¨ë¼ì¸ ë ˆì´ì‹± ì¶”ì²¨ ê²Œì„.">
    <meta name="author" content="Euiyun Edwin Kim">
    <meta name="keywords" content="ë„¤ì˜¨ ë ˆì´ìŠ¤, ë ˆì´ì‹± ê²Œì„, ì‚¬ì´ë²„í‘í¬, ì¶”ì²¨ ê²Œì„, ì˜¨ë¼ì¸ ì¶”ì²¨, ëœë¤ ì„ íƒ, ë ˆí¬ë¦¬ì—ì´ì…˜">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="ì¶”ì²¨ ê²Œì„ í¬í„¸">
    <meta property="og:title" content="ğŸŒŒ ë„¤ì˜¨ ë ˆì´ìŠ¤ - ì‹¤ì‹œê°„ ë ˆì´ì‹± ì¶”ì²¨">
    <meta property="og:description" content="í™”ë ¤í•œ ë„¤ì˜¨ ì‚¬ì¸ì„ ê°€ë¥´ë©° ì§ˆì£¼í•˜ì„¸ìš”! ì•„ì´í…œ ë°•ìŠ¤ë¥¼ íšë“í•˜ì—¬ ì§œë¦¿í•œ ì—­ì „ê·¹ì„ ë§Œë“œì„¸ìš”.">
    <meta property="og:url" content="https://geniuskey.github.io/lottery/neon-race/">
    <meta property="og:image" content="https://geniuskey.github.io/lottery/og-image.png">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ğŸŒŒ ë„¤ì˜¨ ë ˆì´ìŠ¤ - ì‹¤ì‹œê°„ ë ˆì´ì‹± ì¶”ì²¨">
    <meta name="twitter:description" content="í™”ë ¤í•œ ë„¤ì˜¨ ì‚¬ì¸ì„ ê°€ë¥´ë©° ì§ˆì£¼í•˜ì„¸ìš”! ì•„ì´í…œ ë°•ìŠ¤ë¥¼ íšë“í•˜ì—¬ ì§œë¦¿í•œ ì—­ì „ê·¹ì„ ë§Œë“œì„¸ìš”.">
    <meta name="twitter:image" content="https://geniuskey.github.io/lottery/og-image.png">
    
    <!-- Canonical & Favicon -->
    <link rel="canonical" href="https://geniuskey.github.io/lottery/neon-race/">
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸŒŒ</text></svg>">
    <meta name="robots" content="index, follow">


    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #020617;
            --bg-card: rgba(15, 23, 42, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --text-primary: #f1f5f9;
            --text-secondary: #64748b;
            --accent-pink: #ff007f;
            --accent-cyan: #00f2ff;
            --accent-purple: #bc13fe;
            --accent-gold: #ffd700;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .container { display: flex; height: 100vh; width: 100%; }

        /* Sidebar */
        .sidebar {
            width: 280px; min-width: 280px;
            background: var(--bg-card);
            border-right: 1px solid var(--glass-border);
            display: flex; flex-direction: column; z-index: 10;
        }

        .sidebar-header { 
            padding: 15px; border-bottom: 1px solid var(--glass-border); flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center; gap: 10px;
        }
        .header-btns { display: flex; gap: 8px; flex-shrink: 0; }
        .logo-row { display: flex; justify-content: space-between; align-items: center; }
        .logo {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
            letter-spacing: -0.8px;
        }

        .logo .title-emoji {
            filter: drop-shadow(0 0 5px rgba(255, 0, 127, 0.5));
            -webkit-text-fill-color: initial;
            background: none;
        }

        .logo .title-text {
            /* í”„ë¦¬ë¯¸ì—„ ê¸ˆì† ê´‘íƒ íš¨ê³¼ */
            background: linear-gradient(
                to right, 
                var(--accent-pink) 0%, 
                #fff 45%, 
                #fff 55%, 
                var(--accent-pink) 100%
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shine 5s linear infinite;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }

        .help-btn, .sound-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid var(--glass-border); color: var(--text-secondary);
            width: 32px; height: 32px; border-radius: 8px; cursor: pointer; font-size: 1rem; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .help-btn:hover, .sound-btn:hover { background: rgba(255, 255, 255, 0.2); color: var(--text-primary); transform: translateY(-2px); }

        .sidebar-content { padding: 15px; flex: 1; display: flex; flex-direction: column; min-height: 0; overflow-y: auto; }
        .section { margin-bottom: 15px; flex-shrink: 0; }
        .section-title { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }

        .participants-input {
            width: 100%; height: 100px; background: var(--glass-bg); border: 1px solid var(--glass-border);
            border-radius: 8px; color: #fff; padding: 10px; font-size: 0.85rem; resize: none; font-family: inherit;
        }
        .participants-input:focus { outline: none; border-color: var(--accent-pink); }

        .slider-group { margin-bottom: 12px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .slider-label { font-size: 0.8rem; color: var(--text-secondary); }
        .slider-value { font-size: 0.9rem; font-weight: bold; color: var(--accent-pink); }

        input[type="range"] { width: 100%; height: 4px; border-radius: 2px; background: var(--glass-border); -webkit-appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent-pink); cursor: pointer; }

        .btn-group { display: flex; gap: 8px; margin-top: 15px; flex-shrink: 0; }
        .btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-family: inherit; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.2s; }
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-pink), var(--accent-purple));
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 0, 127, 0.3);
        }

        .btn-secondary {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
        }

        .ranking-section {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            min-height: 150px;
            display: flex;
            flex-direction: column;
        }
        .ranking-item { display: flex; align-items: center; padding: 8px; border-radius: 6px; margin-bottom: 4px; background: rgba(255, 255, 255, 0.02); font-size: 0.8rem; transition: all 0.3s; }
        .ranking-rank { width: 24px; font-weight: bold; color: var(--accent-cyan); }
        .ranking-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .ranking-time { font-size: 0.7rem; font-family: monospace; color: var(--text-secondary); margin-left: 8px; }
        .ranking-item-icon { margin-left: 8px; font-size: 1rem; }

        .sidebar-footer { padding: 15px; border-top: 1px solid var(--glass-border); display: flex; justify-content: center; gap: 10px; flex-shrink: 0; }
        .icon-btn { width: 36px; height: 36px; border-radius: 8px; background: var(--glass-bg); border: 1px solid var(--glass-border); color: var(--text-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; text-decoration: none; }
        .icon-btn:hover { background: rgba(255, 255, 255, 0.1); color: var(--text-primary); transform: translateY(-2px); }

        [data-tooltip] { position: relative; }
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            font-size: 0.7rem;
            border-radius: 4px;
            white-space: nowrap;
            margin-bottom: 5px;
        }

        .game-area { flex: 1; position: relative; background: #000; overflow: hidden; }
        #gameCanvas { width: 100%; height: 100%; display: block; cursor: crosshair; }

        .game-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Black Han Sans', sans-serif;
            font-size: 1.8rem;
            color: var(--accent-pink);
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 20px;
            border-radius: 15px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            z-index: 5;
            pointer-events: none;
        }

        .copyright { position: absolute; bottom: 10px; right: 15px; font-size: 0.7rem; color: rgba(255, 255, 255, 0.25); pointer-events: none; user-select: none; }

        .winner-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 0.92); backdrop-filter: blur(10px);
            display: none; flex-direction: column; align-items: center; justify-content: flex-start; 
            padding: 40px 20px; z-index: 1000; overflow-y: auto;
        }
        .winner-overlay.show { display: flex; animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .result-header { text-align: center; margin-bottom: 20px; }
        .winner-label { font-size: 1.2rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 4px; margin-bottom: 10px; }

        .winner-title { 
            font-family: 'Black Han Sans', sans-serif; 
            font-size: 4rem; 
            color: var(--accent-pink); 
            margin-bottom: 5px; 
            text-shadow: 0 0 30px var(--accent-pink);
            animation: championGlow 2s infinite alternate, championPop 0.5s ease-out;
        }
        @keyframes championGlow {
            0% { text-shadow: 0 0 20px var(--accent-pink), 0 0 40px var(--accent-cyan); color: #fff; }
            100% { text-shadow: 0 0 50px var(--accent-purple), 0 0 80px var(--accent-pink); color: var(--accent-pink); }
        }
        @keyframes championPop {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .winner-name { 
            font-size: 2.8rem; 
            color: #fff; 
            margin-bottom: 30px; 
            animation: namePulse 1.5s infinite ease-in-out;
        }
        @keyframes namePulse {
            0%, 100% { transform: scale(1); text-shadow: 0 0 10px #fff; }
            50% { transform: scale(1.05); text-shadow: 0 0 30px var(--accent-gold); color: var(--accent-gold); }
        }

        .final-rankings {
            width: 100%; max-width: 480px;
            max-height: 45vh;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--glass-border);
            border-radius: 20px; padding: 20px;
            margin-bottom: 30px;
        }
        .final-rankings::-webkit-scrollbar { width: 6px; }
        .final-rankings::-webkit-scrollbar-track { background: transparent; }
        .final-rankings::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.15); border-radius: 10px; }
        .final-rankings::-webkit-scrollbar-thumb:hover { background: var(--accent-pink); }
        .final-rankings-title { font-size: 0.9rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; text-align: center; }
        
        .final-ranking-item {
            display: flex; align-items: center; gap: 15px;
            padding: 12px 16px; border-radius: 12px; margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.02);
            animation: resultSlideIn 0.4s ease forwards; opacity: 0;
        }
        @keyframes resultSlideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .final-ranking-item.rank-1 { background: linear-gradient(90deg, rgba(255, 215, 0, 0.15), transparent); border: 1px solid rgba(255, 215, 0, 0.3); }
        .final-ranking-item.rank-2 { background: linear-gradient(90deg, rgba(192, 192, 192, 0.1), transparent); border: 1px solid rgba(192, 192, 192, 0.2); }
        .final-ranking-item.rank-3 { background: linear-gradient(90deg, rgba(205, 127, 50, 0.1), transparent); border: 1px solid rgba(205, 127, 50, 0.2); }

        .final-position { 
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; 
            background: rgba(255, 255, 255, 0.1); border-radius: 50%; font-weight: 700; font-size: 0.9rem;
        }
        .rank-1 .final-position { background: linear-gradient(135deg, #ffd700, #ffaa00); color: #000; box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); }
        .rank-2 .final-position { background: linear-gradient(135deg, #e0e0e0, #a0a0a0); color: #000; }
        .rank-3 .final-position { background: linear-gradient(135deg, #cd7f32, #8b4513); color: #fff; }

        .final-name { flex: 1; font-weight: 600; font-size: 1.1rem; }
        .final-time { font-size: 0.85rem; color: var(--text-secondary); font-family: monospace; }

        .result-buttons { display: flex; gap: 12px; justify-content: center; width: 100%; max-width: 480px; }
        .winner-btn { flex: 1; padding: 15px; font-size: 1.1rem; border-radius: 12px; height: auto; }

        /* Confetti */
        .confetti-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
        .confetti { position: absolute; width: 10px; height: 10px; animation: confettiFall 3s ease-in-out forwards; }
        @keyframes confettiFall {
            0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @media (max-width: 768px) {
            body { overflow-y: auto; height: auto; }
            .container { flex-direction: column-reverse; height: auto; }
            .sidebar { 
                width: 100%; 
                min-width: unset; 
                height: auto;
                max-height: none; 
                border-right: none; 
                border-top: 1px solid var(--glass-border); 
            }
            .sidebar-content {
                overflow-y: visible;
            }
            .game-area { 
                flex: none; 
                width: 100%;
                height: 75vh; 
                min-height: 500px; 
            }
            .ranking-section {
                min-height: 200px;
                max-height: 300px;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.1); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-pink); }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
        <div class="sidebar-header">
            <h1 class="logo"><span class="title-emoji">ğŸ</span> <span class="title-text">ë„¤ì˜¨ ë ˆì´ìŠ¤</span></h1>
            <div class="header-btns">
                <button class="sound-btn" id="soundToggle" title="ì†Œë¦¬ ì¼œê¸°/ë„ê¸°">ğŸ”Š</button>
                <button class="help-btn" id="helpBtn">?</button>
            </div>
        </div>
            <div class="sidebar-content">
                <div class="section">
                    <div class="section-title">ì°¸ì—¬ì ëª…ë‹¨</div>
                    <textarea class="participants-input" id="participants" placeholder="ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ì¤„ë°”ê¿ˆ ë˜ëŠ” ì‰¼í‘œ)\nì˜ˆ: ì² ìˆ˜, ì˜í¬*3, ë¯¼ìˆ˜">ì˜ìˆ˜, ì˜í˜¸, ì˜ì‹, ì˜ì² , ê´‘ìˆ˜, ìƒì² </textarea>
                </div>

                <div class="section">
                    <div class="section-title">âš™ï¸ ê²Œì„ ì„¤ì •</div>
                    <div class="settings-card" style="background:var(--glass-bg); border:1px solid var(--glass-border); border-radius:12px; padding:12px;">
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">íŠ¸ë™ ê¸¸ì´</span>
                                <span class="slider-value" id="lengthValue">10000</span>
                            </div>
                            <input type="range" id="raceLengthSlider" min="3000" max="30000" step="500" value="10000">
                        </div>
                        
                        <div class="slider-group" style="margin-bottom:0;">
                            <div class="slider-header">
                                <span class="slider-label">ì¥ì• ë¬¼ ë°€ë„</span>
                                <span class="slider-value" id="densityValue">ë§ìŒ</span>
                            </div>
                            <input type="range" id="densitySlider" min="20" max="100" step="10" value="60">
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="btn-group">
                        <button class="btn btn-primary" id="startBtn" style="flex: 2;">ğŸ® ì‹œì‘</button>
                        <button class="btn btn-secondary" id="resetBtn" style="flex: 1;">â†º</button>
                        <button class="btn btn-secondary" id="finishBtn" style="flex: 1; background:rgba(239,68,68,0.1); border-color:rgba(239,68,68,0.3); color:#ff4444;">ì¢…ë£Œ</button>
                    </div>
                </div>
                <div class="section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                    <div class="ranking-section">
                        <div class="section-title">ğŸ“Š ì‹¤ì‹œê°„ í˜„í™©</div>
                        <div id="rankingList">
                            <div style="text-align:center; padding:20px; color:var(--text-secondary); font-size:0.8rem;">ëŒ€ê¸° ì¤‘...</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="sidebar-footer">
                <a href="../" class="icon-btn" data-tooltip="ì¶”ì²¨ í¬íƒˆ í™ˆ">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
                </a>
                <button class="icon-btn" id="copyResultBtn" data-tooltip="ê²°ê³¼ ë³µì‚¬">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                </button>
                <a href="https://github.com/geniuskey/lottery" target="_blank" class="icon-btn" data-tooltip="GitHub ì €ì¥ì†Œ">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>
                </a>
                <a href="https://buymeacoffee.com/euiyun" target="_blank" class="icon-btn" data-tooltip="ì»¤í”¼ ì‚¬ì£¼ê¸° â˜•">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.232-.215.03-.437.03-.653.03h-.002c-.215 0-.438 0-.653-.03-.215-.032-.433-.095-.578-.232-.145-.138-.21-.364-.243-.579-.034-.215-.034-.438-.034-.653v-.002c0-.215 0-.438.034-.653.034-.215.1-.441-.243-.579.145-.138.363-.201.578-.232.215-.03.438-.03.653-.03.215 0 .438 0 .653.03.215.032.433.095.578.232.145.138.21.364.243.579.034.215.034.438.034.653v.002c0 .215 0 .438-.034.653-.034.215-.1.441-.243.579z"></path></svg>
                </a>
            </div>
        </aside>
        <main class="game-area">
            <div class="game-timer" id="gameTimer">00:00.00</div>
            <canvas id="gameCanvas"></canvas>
            <div class="copyright">Â© 2025 Euiyun Edwin Kim.</div>
        </main>
    </div>

    <div class="winner-overlay" id="winnerOverlay">
        <div class="confetti-container" id="confettiContainer"></div>
        <div class="result-header">
            <div class="winner-label">ğŸ† CHAMPION</div>
            <div class="winner-title" id="winnerTitle">NEON RACE</div>
            <div class="winner-name" id="winnerName">-</div>
        </div>
        <div class="final-rankings">
            <div class="final-rankings-title">ğŸ ìµœì¢… ìˆœìœ„</div>
            <div id="finalRankingList"></div>
        </div>
        <div class="result-buttons">
            <button class="btn btn-secondary winner-btn" id="copyResultOverlayBtn">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
            <button class="btn btn-primary winner-btn" id="restartBtn">í™•ì¸</button>
        </div>
    </div>

    <canvas id="celebCanvas" style="position:fixed; top:0; left:0; width:100%; height:100%; z-index:1100; pointer-events:none;"></canvas>

    <script>
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.enabled = true;
                this.setupToggleButton();
            }

            setupToggleButton() {
                const btn = document.getElementById('soundToggle');
                if (btn) {
                    btn.onclick = () => {
                        this.enabled = !this.enabled;
                        btn.textContent = this.enabled ? 'ğŸ”Š' : 'ğŸ”‡';
                        if (this.enabled && this.ctx && this.ctx.state === 'suspended') {
                            this.ctx.resume();
                        }
                    };
                }
            }

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }

            // ë¶€ë“œëŸ¬ìš´ ë³¼ë¥¨ ì¡°ì ˆì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹°
            createGain(val = 0.1) {
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(val, this.ctx.currentTime);
                gain.connect(this.ctx.destination);
                return gain;
            }

            playBoost() {
                if (!this.enabled) return;
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.createGain(0.05);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.connect(gain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }

            playHit() {
                if (!this.enabled) return;
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.createGain(0.1);
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playCollect() {
                if (!this.enabled) return;
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.createGain(0.05);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523.25, this.ctx.currentTime); // C5
                osc.frequency.exponentialRampToValueAtTime(1046.5, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            playItemUse(type) {
                if (!this.enabled) return;
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.createGain(0.08);
                if (type === 'lightning') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(1000, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.5);
                } else {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(880, this.ctx.currentTime + 0.2);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }

            playWin() {
                if (!this.enabled) return;
                this.init();
                if (!this.ctx) return;
                [523.25, 659.25, 783.99, 1046.5].forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.createGain(0.03);
                    osc.frequency.setValueAtTime(f, this.ctx.currentTime + i * 0.1);
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.03, this.ctx.currentTime + i * 0.1 + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.0);
                    osc.connect(gain);
                    osc.start(this.ctx.currentTime + i * 0.1);
                    osc.stop(this.ctx.currentTime + 1.5);
                });
            }
        }

        class NeonRace {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.celebCanvas = document.getElementById('celebCanvas');
                this.celebCtx = this.celebCanvas.getContext('2d');
                
                this.sound = new SoundManager();
                this.isRunning = false;
                this.isCelebrating = false; // ì¶•í•˜ ìƒíƒœ í”Œë˜ê·¸
                this.players = [];
                this.obstacles = [];
                this.itemBoxes = [];
                this.particles = [];
                this.cameraX = 0;
                this.raceLength = 10000;
                this.obstacleDensity = 60;
                this.lastUpdate = 0;
                this.gameStartTime = 0;
                this.shake = 0;
                
                // ë¯¸ë‹ˆë§µ ê´€ë ¨
                this.isDraggingMinimap = false;
                this.isAutoTracking = true;
                this.minimapRect = { x: 0, y: 0, w: 0, h: 40 };
                this.lastResultText = ""; // ë§ˆì§€ë§‰ ê²°ê³¼ ì €ì¥ìš©

                this.emojis = [
                    'ğŸ˜€','ğŸ˜ƒ','ğŸ˜„','ğŸ˜','ğŸ˜†','ğŸ˜…','ğŸ˜‚','ğŸ¤£','ğŸ˜‰','ğŸ˜Š','ğŸ˜‡','ğŸ˜','ğŸ¤©','ğŸ˜˜','ğŸ˜—','ğŸ˜š','ğŸ˜‹','ğŸ˜›','ğŸ˜œ','ğŸ¤ª','ğŸ˜','ğŸ¤‘','ğŸ¤—','ğŸ¤­','ğŸ¤«','ğŸ¤”',
                    'ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ»â€â„ï¸','ğŸ¨','ğŸ¯','ğŸ¦','ğŸ®','ğŸ·','ğŸµ','ğŸ”','ğŸ§','ğŸ¦','ğŸ¤','ğŸ£','ğŸ¦‰','ğŸº'
                ];
                this.colors = ['#ff007f', '#00f2ff', '#bc13fe', '#ffdd00', '#39ff14', '#ff4d00'];

                // Background elements
                this.stars = [];
                this.buildings = [];
                this.gridOffset = 0;
                this.initBackground();
                this.items = [
                    { id: 'nitro', icon: 'ğŸš€', chance: 0.4 },
                    { id: 'shield', icon: 'ğŸ›¡ï¸', chance: 0.3 },
                    { id: 'ghost', icon: 'ğŸ‘»', chance: 0.2 },
                    { id: 'lightning', icon: 'ğŸŒ©ï¸', chance: 0.1 }
                ];
                
                this.setupCanvas();
                this.bindEvents();
            }

            setupCanvas() {
                const wrapper = this.canvas.parentElement;
                this.canvas.width = wrapper.clientWidth;
                this.canvas.height = wrapper.clientHeight;

                // ì¶•í•˜ìš© ìº”ë²„ìŠ¤ í¬ê¸° (ì „ì²´ í™”ë©´)
                this.celebCanvas.width = window.innerWidth;
                this.celebCanvas.height = window.innerHeight;

                const padding = 50;
                this.minimapRect = {
                    x: padding, y: this.canvas.height - 60,
                    w: this.canvas.width - padding * 2, h: 40
                };

                // Reinitialize background on resize
                this.initBackground();
            }

            initBackground() {
                // Generate stars
                this.stars = [];
                for (let i = 0; i < 60; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * (this.canvas.height * 0.18),
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random(),
                        twinkleSpeed: 0.02 + Math.random() * 0.03
                    });
                }

                // Generate buildings for cityscape
                this.buildings = [];
                const buildingCount = 25;
                for (let i = 0; i < buildingCount; i++) {
                    const baseWidth = 40 + Math.random() * 80;
                    const height = 50 + Math.random() * 120;
                    const windowCols = Math.floor(Math.random() * 6) + 3;
                    const windowRows = Math.floor(height / 20);

                    // ì°½ë¬¸ ìƒíƒœë¥¼ ë¯¸ë¦¬ ìƒì„± (ì¼œì§/êº¼ì§)
                    const windowStates = [];
                    for (let row = 0; row < windowRows; row++) {
                        windowStates[row] = [];
                        for (let col = 0; col < windowCols; col++) {
                            windowStates[row][col] = {
                                on: Math.random() > 0.3,
                                nextToggle: Math.random() * 300 + 100, // 100-400 í”„ë ˆì„ í›„ í† ê¸€
                                color: Math.random() > 0.7 ? 'neon' : 'warm'
                            };
                        }
                    }

                    this.buildings.push({
                        x: (i / buildingCount) * this.canvas.width * 1.2,
                        width: baseWidth,
                        height: height,
                        color: this.colors[Math.floor(Math.random() * this.colors.length)],
                        windowCols: windowCols,
                        windowRows: windowRows,
                        windowStates: windowStates,
                        parallax: 0.1 + Math.random() * 0.2
                    });
                }

                this.frameCount = 0;
            }

            bindEvents() {
                window.addEventListener('resize', () => { this.setupCanvas(); this.draw(); });
                const handlePointer = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    if (y >= this.minimapRect.y && y <= this.minimapRect.y + this.minimapRect.h &&
                        x >= this.minimapRect.x && x <= this.minimapRect.x + this.minimapRect.w) {
                        this.isDraggingMinimap = true;
                        this.isAutoTracking = false;
                        const pct = (x - this.minimapRect.x) / this.minimapRect.w;
                        this.cameraX = pct * this.raceLength - this.canvas.width / 2;
                        this.clampCamera();
                        this.draw();
                    }
                };
                this.canvas.addEventListener('pointerdown', handlePointer);
                this.canvas.addEventListener('pointermove', (e) => { if (this.isDraggingMinimap) handlePointer(e); });
                window.addEventListener('pointerup', () => { this.isDraggingMinimap = false; });
            }

            clampCamera() {
                const maxCamX = this.raceLength - this.canvas.width * 0.85;
                this.cameraX = Math.max(0, Math.min(this.cameraX, maxCamX));
            }

            prepare(names, raceLength, density, shouldShuffle = false) {
                this.isRunning = false; // ê²Œì„ ì¤‘ë‹¨ ìƒíƒœë¡œ ì„¤ì •
                this.isCelebrating = false; // ì¶•í•˜ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë‹¨
                this.raceLength = raceLength;
                this.obstacleDensity = density;

                // íŠ¸ë™ ì˜ì—­ ê³„ì‚° (ë¹Œë”© ë¼ì¸ ì•„ë˜)
                const trackTop = this.canvas.height * 0.22 + 15; // ë¹Œë”© ë¼ì¸ + ì—¬ìœ 
                const trackBottom = this.canvas.height - 75; // ë¯¸ë‹ˆë§µ ìœ„
                const trackHeight = trackBottom - trackTop;
                const laneHeight = trackHeight / (names.length + 1);

                // ìˆœì„œ ì…”í”Œ ë¡œì§
                const displayNames = shouldShuffle ? [...names].sort(() => Math.random() - 0.5) : names;

                this.players = displayNames.map((name, i) => ({
                    name,
                    emoji: this.emojis[Math.floor(Math.random() * this.emojis.length)],
                    color: this.colors[i % this.colors.length],
                    x: 100, y: trackTop + laneHeight * (i + 0.5),
                    baseY: trackTop + laneHeight * (i + 0.5),
                    vx: 0, vy: 0,
                    speed: 4 + Math.random() * 3,
                    accel: 0.15 + Math.random() * 0.15,
                    trail: [], finished: false, finishTime: 0, rank: 0,
                    collisionTimer: 0, item: null, itemTimer: 0,
                    isGhost: false, hasShield: false,
                    trackTop: trackTop,
                    trackBottom: trackBottom
                }));

                this.obstacles = [];
                const obstacleCount = Math.floor(density * (raceLength / 6000) * 0.8);
                const yBucketSize = trackHeight / obstacleCount;
                for (let i = 0; i < obstacleCount; i++) {
                    this.obstacles.push({
                        x: 800 + Math.random() * (this.raceLength - 1500),
                        y: trackTop + (i * yBucketSize) + Math.random() * yBucketSize,
                        type: Math.random() > 0.6 ? 'boost' : 'slow',
                        size: 50 + Math.random() * 30,
                        angle: Math.random() * Math.PI * 2,
                        rotSpeed: (0.02 + Math.random() * 0.05) * (Math.random() > 0.5 ? 1 : -1)
                    });
                }

                this.itemBoxes = [];
                const boxCount = Math.floor(raceLength / 1200);
                for (let i = 0; i < boxCount; i++) {
                    this.itemBoxes.push({
                        x: 1500 + (i * 1200) + (Math.random() * 400),
                        y: trackTop + Math.random() * trackHeight,
                        size: 40, angle: 0, active: true
                    });
                }

                // íŠ¸ë™ ì˜ì—­ ì €ì¥
                this.trackTop = trackTop;
                this.trackBottom = trackBottom;

                this.particles = [];
                const confettiContainer = document.getElementById('confettiContainer');
                if (confettiContainer) confettiContainer.innerHTML = '';
                
                this.cameraX = 0;
                this.isAutoTracking = true;
                this.shake = 0;
                this.gameStartTime = 0;
                document.getElementById('gameTimer').textContent = '00:00.00';
                this.draw();
            }

            start() {
                if (this.players.length === 0) return;
                this.sound.init();
                this.isRunning = true;
                this.gameStartTime = performance.now();
                this.lastUpdate = performance.now();
                requestAnimationFrame((ts) => this.animate(ts));
            }

            addParticles(x, y, color, count = 10) {
                // ì„±ëŠ¥ ìµœì í™”: ìµœëŒ€ íŒŒí‹°í´ ìˆ˜ ì œí•œ
                if (this.particles.length > 400) return;
                
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x, y, vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
                        life: 1.0, size: Math.random() * 4 + 2, color
                    });
                }
            }

            useItem(p) {
                if (!p.item) return;
                const item = p.item;
                p.item = null;
                this.sound.playItemUse(item.id);
                if (item.id === 'nitro') { p.vx += 30; this.addParticles(p.x, p.y, p.color, 20); }
                else if (item.id === 'shield') { p.hasShield = true; p.itemTimer = 180; }
                else if (item.id === 'ghost') { p.isGhost = true; p.itemTimer = 120; p.vx += 15; }
                else if (item.id === 'lightning') {
                    this.shake = 15;
                    this.players.forEach(other => {
                        if (other !== p && !other.hasShield) { other.vx -= 15; this.addParticles(other.x, other.y, '#ffd700', 10); }
                    });
                }
                this.updateRankingUI();
            }

            forceFinish() {
                if (!this.isRunning) return;
                const now = performance.now();
                const remaining = this.players.filter(p => !p.finished);
                // ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ì™„ì£¼ ì²˜ë¦¬
                remaining.sort((a, b) => b.x - a.x);
                remaining.forEach((p, i) => {
                    p.finished = true;
                    p.trail = [];
                    p.finishTime = now + i; // ì•„ì£¼ ì‘ì€ ì°¨ì´ë¥¼ ë‘ì–´ ìˆœìœ„ ìœ ì§€
                });
                this.updateRankingUI();
                this.endGame();
            }

            update(dt) {
                const dtScale = dt * 60;
                this.shake *= 0.9;

                // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ (ê²Œì„ ì¤‘ë‹¨ ì¤‘ì—ë„ ì‹¤í–‰ë˜ì–´ì•¼ í­ì£½ì´ ë³´ì„)
                this.particles.forEach(part => { 
                    part.x += part.vx; 
                    part.y += part.vy; 
                    part.life -= 0.02; 
                });
                this.particles = this.particles.filter(part => part.life > 0);

                if (!this.isRunning) return;

                const elapsed = (performance.now() - this.gameStartTime) / 1000;
                const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const s = Math.floor(elapsed % 60).toString().padStart(2, '0');
                const ms = Math.floor((elapsed % 1) * 100).toString().padStart(2, '0');
                document.getElementById('gameTimer').textContent = `${m}:${s}.${ms}`;

                this.obstacles.forEach(obs => { obs.angle += obs.rotSpeed * dtScale; });
                this.itemBoxes.forEach(box => { box.angle += 0.05 * dtScale; });

                this.players.forEach(p => {
                    if (p.finished) {
                        const friction = Math.pow(0.9, dtScale);
                        p.vx *= friction; p.vy *= friction;
                        p.x += p.vx * dtScale; p.y += p.vy * dtScale;
                        const stopLimit = this.raceLength + 100;
                        if (p.x > stopLimit) p.x = stopLimit;
                        return;
                    }

                    if (p.itemTimer > 0) { p.itemTimer -= dtScale; if (p.itemTimer <= 0) { p.isGhost = false; p.hasShield = false; } }
                    if (p.item && Math.random() < 0.01) this.useItem(p);

                    // --- ì—­ì „ ë“œë¼ë§ˆë¥¼ ìœ„í•œ ë™ì  ë¬¼ë¦¬ ë¡œì§ ---
                    // í˜„ì¬ ìˆœìœ„ ê³„ì‚° (ë¬¼ë¦¬ìš©)
                    const sortedForPhysics = [...this.players].sort((a, b) => b.x - a.x);
                    const myRank = sortedForPhysics.indexOf(p) + 1;
                    const totalPlayers = this.players.length;

                    // 1. í›„ë¯¸ ê·¸ë£¹ ì¶”ê²© ê°€ì† (Catch-up)
                    // ë’¤ì— ìˆì„ìˆ˜ë¡ ê°€ì†ë„ ë³´ë„ˆìŠ¤ ë¶€ì—¬ (ìµœëŒ€ 1.5ë°°)
                    const catchUpBonus = 1 + ((myRank - 1) / totalPlayers) * 0.5;
                    
                    // 2. ì„ ë‘ ê³µê¸° ì €í•­ (Air Resistance)
                    // 1ë“±ì´ 2ë“±ê³¼ ê±°ë¦¬ê°€ 800px ì´ìƒ ë²Œì–´ì§€ë©´ ì†ë„ ë¯¸ì„¸ ê°ì†
                    let resistance = 1.0;
                    if (myRank === 1 && totalPlayers > 1) {
                        const distToSecond = p.x - sortedForPhysics[1].x;
                        if (distToSecond > 800) resistance = 0.985;
                    }

                    p.vy *= Math.pow(0.92, dtScale);
                    p.vx += p.accel * dtScale * catchUpBonus;
                    p.vx *= Math.pow(0.97, dtScale) * resistance;
                    p.x += (p.speed + p.vx) * dtScale;
                    p.y += p.vy * dtScale;
                    // ---------------------------------------

                    // íƒ„ì„± ë†’ì€ Bar ì¶©ëŒ (íŠ¸ë™ ìƒí•˜ ê²½ê³„)
                    const bounceMargin = 18; // ìºë¦­í„° ë°˜ê²½
                    const topBound = p.trackTop + bounceMargin;
                    const bottomBound = p.trackBottom - bounceMargin;

                    if (p.y < topBound) {
                        p.y = topBound;
                        p.vy = Math.abs(p.vy) + 12; // íƒ•! í•˜ê³  íŠ•ê¹€
                        this.addParticles(p.x, p.y, '#ff007f', 5);
                    }
                    if (p.y > bottomBound) {
                        p.y = bottomBound;
                        p.vy = -(Math.abs(p.vy) + 12); // íƒ•! í•˜ê³  íŠ•ê¹€
                        this.addParticles(p.x, p.y, '#ffd700', 5);
                    }

                    if (p.collisionTimer > 0) p.collisionTimer -= dtScale;
                    if (!p.isGhost) {
                        p.trail.push({x: p.x, y: p.y});
                        if (p.trail.length > 25) p.trail.shift();
                    }

                    this.itemBoxes.forEach(box => {
                        if (box.active && Math.abs(p.x - box.x) < 40 && Math.abs(p.y - box.y) < 40) {
                            box.active = false;
                            this.sound.playCollect();
                            if (!p.item) {
                                // ìˆœìœ„ì— ë”°ë¥¸ ì°¨ë“± ì•„ì´í…œ íšë“ ë¡œì§
                                const sortedForItems = [...this.players].sort((a, b) => b.x - a.x);
                                const rank = sortedForItems.indexOf(p) + 1;
                                const total = this.players.length;
                                
                                let itemPool = [];
                                if (rank === 1) {
                                    // 1ë“±: ì£¼ë¡œ ì‰´ë“œ, ê°€ë” ë¶€ìŠ¤íŠ¸
                                    itemPool = ['shield', 'shield', 'shield', 'nitro'];
                                } else if (rank <= total / 2) {
                                    // ì¤‘ìœ„ê¶Œ: ê³¨ê³ ë£¨
                                    itemPool = ['nitro', 'nitro', 'shield', 'ghost', 'lightning'];
                                } else {
                                    // í•˜ìœ„ê¶Œ: ê°•ë ¥í•œ ì—­ì „ ì•„ì´í…œ (ë‹ˆíŠ¸ë¡œ, ë²ˆê°œ)
                                    itemPool = ['nitro', 'nitro', 'nitro', 'lightning', 'lightning', 'ghost'];
                                }
                                
                                const selectedId = itemPool[Math.floor(Math.random() * itemPool.length)];
                                p.item = this.items.find(it => it.id === selectedId);
                                this.updateRankingUI();
                            }
                        }
                    });

                    this.obstacles.forEach(obs => {
                        const dx = p.x - obs.x; const dy = p.y - obs.y; const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < obs.size / 2 && p.collisionTimer <= 0 && !p.isGhost) {
                            const nx = dx / dist; const ny = dy / dist; const tx = -ny; const ty = nx;
                            const surfaceSpeed = (obs.size / 2) * obs.rotSpeed * 15;
                            if (obs.type === 'boost') { p.vx += nx * 15 + tx * surfaceSpeed; p.vy += ny * 15 + ty * surfaceSpeed; this.addParticles(p.x, p.y, '#00f2ff', 8); this.sound.playBoost(); }
                            else if (!p.hasShield) {
                                p.vx = nx * 5 + tx * surfaceSpeed * 0.5;
                                const vDir = Math.abs(ny) < 0.1 ? (Math.random() > 0.5 ? 1 : -1) : Math.sign(ny);
                                p.vy = vDir * Math.max(Math.abs(ny * 25), 18) + ty * surfaceSpeed;
                                this.addParticles(p.x, p.y, '#ff4444', 5);
                                this.sound.playHit();
                            }
                            p.collisionTimer = 15;
                        }
                    });

                    if (p.x >= this.raceLength) {
                        p.finished = true; p.trail = []; p.finishTime = performance.now();
                        p.rank = this.players.filter(pl => pl.finished).length;
                        this.addParticles(p.x, p.y, p.color, 30);
                        this.sound.playWin(); // Individual finish sound
                        this.updateRankingUI();
                    }
                });

                // ì°¸ì—¬ì ê°„ ì¶©ëŒ ì²˜ë¦¬
                for (let i = 0; i < this.players.length; i++) {
                    const p1 = this.players[i];
                    if (p1.finished) continue;

                    for (let j = i + 1; j < this.players.length; j++) {
                        const p2 = this.players[j];
                        if (p2.finished) continue;

                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = 35; // ì¶©ëŒ ê±°ë¦¬

                        if (dist < minDist && dist > 0) {
                            // ì¶©ëŒ! ì„œë¡œ ë°€ì–´ë‚´ê¸°
                            const nx = dx / dist;
                            const ny = dy / dist;
                            const overlap = minDist - dist;

                            // ìœ„ì¹˜ ë³´ì •
                            p1.x -= nx * overlap * 0.5;
                            p1.y -= ny * overlap * 0.5;
                            p2.x += nx * overlap * 0.5;
                            p2.y += ny * overlap * 0.5;

                            // ì†ë„ êµí™˜ (íƒ„ì„± ì¶©ëŒ)
                            const relVx = p1.vx - p2.vx;
                            const relVy = p1.vy - p2.vy;
                            const impactSpeed = relVx * nx + relVy * ny;

                            if (impactSpeed > 0) {
                                const bounce = 0.8;
                                p1.vx -= impactSpeed * nx * bounce;
                                p1.vy -= impactSpeed * ny * bounce + (Math.random() - 0.5) * 8;
                                p2.vx += impactSpeed * nx * bounce;
                                p2.vy += impactSpeed * ny * bounce + (Math.random() - 0.5) * 8;

                                // íŒŒí‹°í´ ì´í™íŠ¸
                                const midX = (p1.x + p2.x) / 2;
                                const midY = (p1.y + p2.y) / 2;
                                this.addParticles(midX, midY, '#ffffff', 5);
                            }
                        }
                    }
                }

                if (this.isAutoTracking && !this.isDraggingMinimap) {
                    const activePlayers = this.players.filter(p => !p.finished);
                    if (activePlayers.length > 0) {
                        const maxX = Math.max(...activePlayers.map(p => p.x));
                        let targetCameraX = Math.max(0, maxX - this.canvas.width * 0.35);
                        this.cameraX += (targetCameraX - this.cameraX) * 0.1;
                        this.clampCamera();
                    }
                }

                // ë§¤ í”„ë ˆì„ ë­í‚¹ UI ì—…ë°ì´íŠ¸ (ì§„í–‰ % ì‹¤ì‹œê°„ ë°˜ì˜)
                this.updateRankingUI();

                if (this.players.every(p => p.finished)) { setTimeout(() => this.endGame(), 2500); }
            }

            updateRankingUI() {
                const finished = this.players.filter(p => p.finished).sort((a, b) => a.finishTime - b.finishTime);
                const racing = this.players.filter(p => !p.finished).sort((a, b) => b.x - a.x);
                
                const list = document.getElementById('rankingList');
                let html = "";

                const getMedal = (rank) => {
                    if (rank === 1) return "ğŸ¥‡ ";
                    if (rank === 2) return "ğŸ¥ˆ ";
                    if (rank === 3) return "ğŸ¥‰ ";
                    return "";
                };

                // ì™„ì£¼ì ëª©ë¡
                finished.forEach((p, i) => {
                    const rank = i + 1;
                    const time = (p.finishTime - this.gameStartTime) / 1000;
                    html += `
                        <div class="ranking-item" style="border-left: 3px solid ${p.color}">
                            <span class="ranking-rank">${rank}</span>
                            <span class="ranking-name">${p.emoji} ${p.name} ${p.item ? `<span class="ranking-item-icon">${p.item.icon}</span>` : ''}</span>
                            <span class="ranking-time">${getMedal(rank)}${time.toFixed(2)}s</span>
                        </div>
                    `;
                });

                // êµ¬ë¶„ì„  (ë ˆì´ì‹± ì¤‘ì¸ ì‚¬ëŒì´ ìˆì„ ë•Œë§Œ)
                if (racing.length > 0) {
                    if (finished.length > 0) {
                        html += `<div style="text-align:center; font-size:0.65rem; color:var(--text-secondary); margin: 10px 0; letter-spacing:1px;">â€” ë ˆì´ì‹± ì¤‘ â€”</div>`;
                    }
                    
                    racing.forEach((p, i) => {
                        const rank = finished.length + i + 1;
                        const progress = Math.floor((p.x / this.raceLength) * 100);
                        html += `
                            <div class="ranking-item" style="border-left: 3px solid ${p.color}; opacity: 0.85;">
                                <span class="ranking-rank">${rank}</span>
                                <span class="ranking-name">${p.emoji} ${p.name} ${p.item ? `<span class="ranking-item-icon">${p.item.icon}</span>` : ''}</span>
                                <span class="ranking-time">${progress}%</span>
                            </div>
                        `;
                    });
                }

                list.innerHTML = html || `<div style="text-align:center; padding:20px; color:var(--text-secondary); font-size:0.8rem;">ëŒ€ê¸° ì¤‘...</div>`;
            }

            createConfetti() {
                const container = document.getElementById('confettiContainer');
                const colors = ['#ff007f', '#00f2ff', '#bc13fe', '#ffd700', '#39ff14'];
                // ì„±ëŠ¥ ìµœì í™”: ì»¨í˜í‹° ìˆ˜ ê°ì†Œ (100 -> 50)
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.width = Math.random() * 8 + 5 + 'px';
                    confetti.style.height = confetti.style.width;
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
                    container.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }
            }

            endGame() {
                if (!this.isRunning) return;
                this.isRunning = false;
                this.isCelebrating = true; 
                
                const sorted = [...this.players].sort((a, b) => {
                    if (a.finished && b.finished) return a.finishTime - b.finishTime;
                    if (a.finished) return -1;
                    if (b.finished) return 1;
                    return b.x - a.x;
                });
                
                const winner = sorted[0];
                document.getElementById('winnerName').textContent = `${winner.emoji} ${winner.name}`;
                
                // ìµœì¢… ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ ìƒì„±
                const finalRankingList = document.getElementById('finalRankingList');
                finalRankingList.innerHTML = sorted.map((p, i) => {
                    const rank = i + 1;
                    const medal = (rank === 1) ? "ğŸ¥‡ " : (rank === 2) ? "ğŸ¥ˆ " : (rank === 3) ? "ğŸ¥‰ " : "";
                    const timeText = p.finished ? `${medal}${((p.finishTime - this.gameStartTime) / 1000).toFixed(2)}s` : `${Math.floor((p.x / this.raceLength) * 100)}%`;
                    return `
                        <div class="final-ranking-item rank-${rank}" style="animation-delay: ${i * 0.1}s">
                            <span class="final-position">${rank}</span>
                            <span class="final-name">${p.emoji} ${p.name}</span>
                            <span class="final-time">${timeText}</span>
                        </div>
                    `;
                }).join('');

                document.getElementById('winnerOverlay').classList.add('show');
                document.getElementById('confettiContainer').innerHTML = '';
                this.createConfetti();
                
                // ë§ˆì§€ë§‰ ê²°ê³¼ í…ìŠ¤íŠ¸ ì €ì¥
                this.lastResultText = this.getResultText();

                // ì¶•í•˜ í­ì£½ ì—°ì¶œ (ì„±ëŠ¥ ìµœì í™” ë²„ì „)
                let count = 0;
                const winEmojis = ['ğŸ†', 'âœ¨', 'ğŸ‰', 'ğŸŒŸ', 'ğŸ‘‘'];
                const firework = () => {
                    if (!this.isCelebrating || count > 12) { 
                        this.isCelebrating = false; 
                        return;
                    }
                    const x = Math.random() * this.celebCanvas.width;
                    const y = Math.random() * this.celebCanvas.height;
                    const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                    
                    this.addParticles(x, y, color, 25); // íŒŒí‹°í´ ìˆ˜ ê°ì†Œ (50 -> 25)
                    
                    for(let i=0; i<3; i++) { // ì´ëª¨ì§€ ìˆ˜ ê°ì†Œ (5 -> 3)
                        this.particles.push({
                            x, y, 
                            vx: (Math.random() - 0.5) * 15, 
                            vy: (Math.random() - 0.5) * 15,
                            life: 1.2, 
                            size: 20, 
                            color: '#fff',
                            text: winEmojis[Math.floor(Math.random() * winEmojis.length)]
                        });
                    }

                    this.shake = 10; // í”ë“¤ë¦¼ ê°•ë„ ì™„í™”
                    count++;
                    setTimeout(firework, 400 + Math.random() * 400); // ê°„ê²© ì¦ê°€
                };
                firework();
            }

            draw() {
                const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height;
                const cctx = this.celebCtx;

                // ë©”ì¸ ê²Œì„ ìº”ë²„ìŠ¤ ì´ˆê¸°í™” - ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
                const bgGrad = ctx.createLinearGradient(0, 0, 0, h);
                bgGrad.addColorStop(0, '#0a0015');
                bgGrad.addColorStop(0.3, '#020617');
                bgGrad.addColorStop(1, '#0d0d2b');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);

                // ì¶•í•˜ìš© ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                cctx.clearRect(0, 0, this.celebCanvas.width, this.celebCanvas.height);

                // ===== ë°°ê²½ ìš”ì†Œ ê·¸ë¦¬ê¸° =====
                // 1. ë³„ ê·¸ë¦¬ê¸°
                this.stars.forEach(star => {
                    star.brightness += star.twinkleSpeed;
                    const alpha = 0.3 + Math.abs(Math.sin(star.brightness)) * 0.7;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fill();
                });

                // 2. ë„¤ì˜¨ ê·¸ë¦¬ë“œ (íŠ¸ë™ í•˜ë‹¨, ë¯¸ë‹ˆë§µ ìœ„)
                this.gridOffset += 0.5;
                const gridY = h - 70;
                const gridH = 25;
                const gridGrad = ctx.createLinearGradient(0, gridY, 0, gridY + gridH);
                gridGrad.addColorStop(0, 'rgba(188, 19, 254, 0.25)');
                gridGrad.addColorStop(1, 'rgba(188, 19, 254, 0)');
                ctx.fillStyle = gridGrad;
                ctx.fillRect(0, gridY, w, gridH);

                // ê·¸ë¦¬ë“œ ë¼ì¸
                ctx.strokeStyle = 'rgba(0, 242, 255, 0.12)';
                ctx.lineWidth = 1;
                const gridSpacing = 40;
                for (let x = -this.gridOffset % gridSpacing; x < w; x += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, gridY);
                    ctx.lineTo(x + 15, gridY + gridH);
                    ctx.stroke();
                }

                // 3. ë¹Œë”© ìŠ¤ì¹´ì´ë¼ì¸ (íŒ¨ëŸ´ë™ìŠ¤) - íŠ¸ë™ ìœ„ìª½ì— ë°°ì¹˜
                this.trackTopY = h * 0.22; // íŠ¸ë™ ì‹œì‘ Y ì¢Œí‘œ (ë” ë†’ê²Œ)
                const buildingBaseY = this.trackTopY;

                this.frameCount = (this.frameCount || 0) + 1;

                this.buildings.forEach(b => {
                    const parallaxX = (b.x - (this.cameraX * b.parallax)) % (w * 1.2);
                    const bx = parallaxX < -b.width ? parallaxX + w * 1.2 : parallaxX;

                    // ë¹Œë”© ë³¸ì²´
                    ctx.fillStyle = 'rgba(10, 10, 30, 0.95)';
                    ctx.fillRect(bx, buildingBaseY - b.height, b.width, b.height);

                    // ë¹Œë”© í…Œë‘ë¦¬ ë„¤ì˜¨
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.strokeRect(bx, buildingBaseY - b.height, b.width, b.height);
                    ctx.globalAlpha = 1;

                    // ì°½ë¬¸ (ì²œì²œíˆ ë¸”ë§í‚¹)
                    const winW = (b.width - 10) / b.windowCols;
                    const winH = 8;
                    for (let row = 0; row < b.windowRows; row++) {
                        for (let col = 0; col < b.windowCols; col++) {
                            const ws = b.windowStates[row][col];

                            // ì²œì²œíˆ í† ê¸€
                            ws.nextToggle--;
                            if (ws.nextToggle <= 0) {
                                ws.on = !ws.on;
                                ws.nextToggle = Math.random() * 400 + 150; // 150-550 í”„ë ˆì„
                            }

                            if (ws.on) {
                                const wx = bx + 5 + col * winW;
                                const wy = buildingBaseY - b.height + 10 + row * 18;
                                const winColor = ws.color === 'neon' ? b.color : 'rgba(255, 220, 150, 0.7)';
                                ctx.fillStyle = winColor;
                                ctx.fillRect(wx, wy, winW - 3, winH);
                            }
                        }
                    }

                    // ì˜¥ìƒ ì•ˆí…Œë‚˜/ë„¤ì˜¨ì‚¬ì¸ (ê³ ì •, ëœë¤ ì•„ë‹˜)
                    if (b.height > 80) {
                        ctx.strokeStyle = b.color;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = b.color;
                        ctx.beginPath();
                        ctx.moveTo(bx + b.width / 2, buildingBaseY - b.height);
                        ctx.lineTo(bx + b.width / 2, buildingBaseY - b.height - 15);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                });

                // 4. ìˆ˜í‰ì„  ë„¤ì˜¨ ë¼ì¸ (íŠ¸ë™ ìƒë‹¨ ê²½ê³„)
                ctx.strokeStyle = '#ff007f';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#ff007f';
                ctx.beginPath();
                ctx.moveTo(0, buildingBaseY);
                ctx.lineTo(w, buildingBaseY);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // íŠ¸ë™ ì˜ì—­ ë°°ê²½ (ë¹Œë”© ë¼ì¸ ì•„ë˜)
                const trackGrad = ctx.createLinearGradient(0, buildingBaseY, 0, h);
                trackGrad.addColorStop(0, 'rgba(2, 6, 23, 0.95)');
                trackGrad.addColorStop(1, 'rgba(13, 13, 43, 0.9)');
                ctx.fillStyle = trackGrad;
                ctx.fillRect(0, buildingBaseY, w, h - buildingBaseY);

                // ===== ê²Œì„ ìš”ì†Œ ê·¸ë¦¬ê¸° =====
                ctx.save();
                if (this.shake > 0.1) ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake);

                // ê²Œì„ ìš”ì†ŒëŠ” ì¹´ë©”ë¼ ì¢Œí‘œê³„ ì‚¬ìš©
                ctx.save();
                ctx.translate(-this.cameraX, 0);

                // íŠ¸ë™ ìƒí•˜ ê²½ê³„ ë°” ê·¸ë¦¬ê¸°
                const trackTop = this.trackTop || h * 0.38 + 15;
                const trackBottom = this.trackBottom || h - 75;

                // ìƒë‹¨ ë°” (í•‘í¬ ë„¤ì˜¨ - ë¹Œë”© ë¼ì¸ê³¼ ì¼ì¹˜)
                ctx.fillStyle = '#ff007f';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#ff007f';
                ctx.fillRect(this.cameraX, trackTop - 5, this.canvas.width, 5);
                ctx.shadowBlur = 0;

                // í•˜ë‹¨ ë°” (ê³¨ë“œ)
                ctx.fillStyle = '#ffd700';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#ffd700';
                ctx.fillRect(this.cameraX, trackBottom, this.canvas.width, 5);
                ctx.shadowBlur = 0;

                // ê°€ì´ë“œ ë¼ì¸ (íŠ¸ë™ ì˜ì—­ ë‚´)
                ctx.strokeStyle = 'rgba(0, 242, 255, 0.05)';
                ctx.lineWidth = 1;
                for (let i = 0; i < this.raceLength + 2000; i += 200) {
                    ctx.beginPath(); ctx.moveTo(i, trackTop); ctx.lineTo(i, trackBottom); ctx.stroke();
                }
                this.obstacles.forEach(obs => {
                    const isBoost = obs.type === 'boost';
                    ctx.save(); ctx.translate(obs.x, obs.y); ctx.rotate(obs.angle);
                    ctx.shadowBlur = 20; ctx.shadowColor = isBoost ? '#00f2ff' : '#ff0055';
                    ctx.fillStyle = isBoost ? 'rgba(0, 242, 255, 0.2)' : 'rgba(255, 0, 85, 0.2)';
                    ctx.strokeStyle = isBoost ? '#00f2ff' : '#ff0055'; ctx.lineWidth = 2;
                    ctx.beginPath();
                    for(let i=0; i<6; i++) {
                        const ang = (i/6) * Math.PI * 2;
                        const px = Math.cos(ang) * (obs.size/2); const py = Math.sin(ang) * (obs.size/2);
                        if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                    ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
                });
                this.itemBoxes.forEach(box => {
                    if (!box.active) return;
                    ctx.save(); ctx.translate(box.x, box.y); ctx.rotate(box.angle);
                    ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2; ctx.strokeRect(-box.size/2, -box.size/2, box.size, box.size);
                    ctx.font = '24px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸ', 0, 0); ctx.restore();
                });
                const finishX = this.raceLength;
                const grad = ctx.createLinearGradient(finishX - 50, 0, finishX + 50, 0);
                grad.addColorStop(0, 'transparent'); grad.addColorStop(0.5, '#ff007f'); grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad; ctx.fillRect(finishX - 50, trackTop, 100, trackBottom - trackTop);
                this.players.forEach(p => {
                    if (p.trail.length > 1) {
                        ctx.save(); ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.strokeStyle = p.color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                        ctx.beginPath(); ctx.moveTo(p.trail[0].x, p.trail[0].y);
                        p.trail.forEach((t, idx) => { ctx.globalAlpha = idx / p.trail.length; ctx.lineTo(t.x, t.y); });
                        ctx.stroke(); ctx.restore();
                    }
                    ctx.save(); ctx.translate(p.x, p.y);
                    if (p.isGhost) ctx.globalAlpha = 0.4;
                    if (p.hasShield) { ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2); ctx.stroke(); }
                    ctx.font = '36px serif'; ctx.textAlign = 'center'; ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
                    ctx.fillText(p.emoji, 0, 12); ctx.restore();
                    ctx.font = 'bold 13px "Noto Sans KR"'; ctx.fillStyle = '#fff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                    ctx.strokeText(p.name, p.x, p.y - 30); ctx.fillText(p.name, p.x, p.y - 30);
                });
                ctx.restore(); // camera translate restore

                // íŒŒí‹°í´ì€ celebCanvasì— ê·¸ë¦¬ê¸° (í™”ë©´ ì¢Œí‘œê³„ ì‚¬ìš©)
                this.particles.forEach(part => { 
                    cctx.globalAlpha = part.life; 
                    if (part.text) {
                        cctx.font = `${part.size}px serif`;
                        cctx.textAlign = 'center';
                        cctx.textBaseline = 'middle';
                        cctx.fillText(part.text, part.x, part.y);
                    } else {
                        cctx.fillStyle = part.color; 
                        cctx.fillRect(part.x, part.y, part.size, part.size); 
                    }
                });
                
                ctx.restore(); // shake translate restore
                this.drawMinimap();
            }

            drawMinimap() {
                const ctx = this.ctx; const { x, y, w, h } = this.minimapRect;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; ctx.strokeStyle = 'rgba(0, 242, 255, 0.2)'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill(); ctx.stroke();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.beginPath(); ctx.moveTo(x, y + h/2); ctx.lineTo(x + w, y + h/2); ctx.stroke();
                this.players.forEach(p => { const px = x + (p.x / this.raceLength) * w; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(px, y + h/2, 4, 0, Math.PI * 2); ctx.fill(); });
                const viewW = (this.canvas.width / this.raceLength) * w;
                const viewX = (this.cameraX / this.raceLength) * w + x;
                ctx.strokeStyle = 'rgba(0, 242, 255, 0.8)'; ctx.lineWidth = 2;
                ctx.strokeRect(viewX, y, viewW, h); ctx.fillStyle = 'rgba(0, 242, 255, 0.1)'; ctx.fillRect(viewX, y, viewW, h);
            }

                        animate(timestamp) {

                            const dt = (timestamp - this.lastUpdate) / 1000;

                            this.lastUpdate = timestamp;

                            this.update(dt);

                            this.draw();

                            if (this.isRunning || this.particles.length > 0 || this.isDraggingMinimap || this.isCelebrating) {

                                requestAnimationFrame((ts) => this.animate(ts));

                            }

                        }

            

            getResultText() {
                // ê²Œì„ ì¤‘ì´ ì•„ë‹ˆê³  ì´ˆê¸°í™”ëœ ìƒíƒœë¼ë©´ ë§ˆì§€ë§‰ ì €ì¥ëœ ê²°ê³¼ë¥¼ ë°˜í™˜
                if (!this.isRunning && !this.isCelebrating && this.lastResultText && this.players.every(p => !p.finished)) {
                    return this.lastResultText;
                }

                const sorted = [...this.players].sort((a, b) => {
                    if (a.finished && b.finished) return a.finishTime - b.finishTime;
                    if (a.finished) return -1;
                    if (b.finished) return 1;
                    return b.x - a.x;
                });

                const getMedal = (rank) => {
                    if (rank === 1) return "ğŸ¥‡ ";
                    if (rank === 2) return "ğŸ¥ˆ ";
                    if (rank === 3) return "ğŸ¥‰ ";
                    return "";
                };

                let text = "ğŸŒŒ ë„¤ì˜¨ ë ˆì´ìŠ¤ ê²°ê³¼ ğŸŒŒ\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n";
                sorted.forEach((p, i) => {
                    const rank = i + 1;
                    if (p.finished && this.gameStartTime > 0) {
                        const time = (p.finishTime - this.gameStartTime) / 1000;
                        text += `${rank}ë“±: ${p.emoji} ${p.name} (${getMedal(rank)}${time.toFixed(2)}s)\n`;
                    } else {
                        const progress = Math.floor((p.x / this.raceLength) * 100);
                        text += `${rank}ë“±: ${p.emoji} ${p.name} (${progress}% ì§„í–‰ ì¤‘)\n`;
                    }
                });
                return text;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const game = new NeonRace(canvas);
            const participantsInput = document.getElementById('participants');
            const raceLengthSlider = document.getElementById('raceLengthSlider');
            const raceLengthValue = document.getElementById('lengthValue');
            const densitySlider = document.getElementById('densitySlider');
            const densityValue = document.getElementById('densityValue');

            function parseParticipants(input) {
                const names = input.split(/[,\n]/).map(n => n.trim()).filter(n => n);
                const result = [];
                for (const name of names) {
                    const match = name.match(/^(.+)\*(\d+)$/);
                    if (match) {
                        const baseName = match[1].trim();
                        const count = parseInt(match[2]);
                        for (let i = 0; i < count; i++) result.push(baseName);
                    } else { result.push(name); }
                }
                return result;
            }

            function getDensityText(val) { 
                if (val < 40) return "ì ìŒ"; if (val < 70) return "ë³´í†µ"; if (val < 90) return "ë§ìŒ"; return "ë§¤ìš° ë§ìŒ";
            }

            function updateInit(shouldShuffle = false) {
                const names = parseParticipants(participantsInput.value);
                const length = parseInt(raceLengthSlider.value);
                const density = parseInt(densitySlider.value);
                game.prepare(names, length, density, shouldShuffle);
                localStorage.setItem('neon-race-participants', participantsInput.value);
                localStorage.setItem('neon-race-length', length);
                localStorage.setItem('neon-race-density', density);
            }

            participantsInput.addEventListener('input', () => updateInit(false));
            raceLengthSlider.addEventListener('input', (e) => { raceLengthValue.textContent = e.target.value; updateInit(false); });
            densitySlider.addEventListener('input', (e) => { densityValue.textContent = getDensityText(e.target.value); updateInit(false); });

            document.getElementById('startBtn').addEventListener('click', () => { 
                if (game.isRunning) return; 
                game.start(); 
                // ëª¨ë°”ì¼ì—ì„œ ì‹œì‘ ì‹œ ê²Œì„ í™”ë©´ìœ¼ë¡œ ìë™ ìŠ¤í¬ë¡¤
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
            document.getElementById('resetBtn').addEventListener('click', () => { updateInit(true); });
            document.getElementById('finishBtn').addEventListener('click', () => { game.forceFinish(); });
            document.getElementById('helpBtn').addEventListener('click', () => { alert('ğŸŒŒ ë„¤ì˜¨ ë ˆì´ìŠ¤\n\n1. ì°¸ì—¬ìë“¤ì´ ë„¤ì˜¨ ë„ì‹œë¥¼ ì§ˆì£¼í•©ë‹ˆë‹¤.\n2. íŒŒë€ìƒ‰ ìœ¡ê°í˜•ì€ ê°€ì†(Boost), ë¹¨ê°„ìƒ‰ì€ ê°ì†(Slow)ì…ë‹ˆë‹¤.\n3. ğŸ ì•„ì´í…œ ë°•ìŠ¤ë¥¼ íšë“í•˜ì—¬ ë§ˆë¦¬ì˜¤ ì¹´íŠ¸ì²˜ëŸ¼ ì—­ì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n4. í•˜ë‹¨ ë¯¸ë‹ˆë§µì„ ë“œë˜ê·¸í•˜ì—¬ ì‹œì ì„ ê³ ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n5. â†º ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì°¸ì—¬ì ìˆœì„œê°€ ë¬´ì‘ìœ„ë¡œ ì„ì…ë‹ˆë‹¤.'); });
            document.getElementById('restartBtn').addEventListener('click', () => { document.getElementById('winnerOverlay').classList.remove('show'); updateInit(false); });
            document.getElementById('copyResultBtn').addEventListener('click', () => { const text = game.getResultText(); navigator.clipboard.writeText(text).then(() => alert('ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!')); });
            document.getElementById('copyResultOverlayBtn').addEventListener('click', () => { const text = game.getResultText(); navigator.clipboard.writeText(text).then(() => alert('ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!')); });

            const savedNames = localStorage.getItem('neon-race-participants');
            if (savedNames) participantsInput.value = savedNames;
            const savedLength = localStorage.getItem('neon-race-length');
            if (savedLength) { raceLengthSlider.value = savedLength; raceLengthValue.textContent = savedLength; }
            const savedDensity = localStorage.getItem('neon-race-density');
            if (savedDensity) { densitySlider.value = savedDensity; densityValue.textContent = getDensityText(savedDensity); }

            updateInit(false);
        });
    </script>
</body>
</html>